{
  "source_file_path_relative_to_docusaurus_root": "../md/interceptors.mdx",
  "source_file_content_hash": "1da431faf4c72d2f4c10d7a3ac6f1e50dd7d67f216e1113328056b0d0ace0c72",
  "segments": [
    {
      "segment_id": "58cfcc64",
      "source_content": "---\nid: interceptors\ntitle: Interceptors\n---",
      "source_content_hash": "7d4409d4ef2024394a6e00d612e6941e079b15e8ebda9c3eb3dc19d8a83b42b5",
      "node_type": "yaml",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_58cfcc64"
      }
    },
    {
      "segment_id": "4d1292be",
      "source_content": "import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';",
      "source_content_hash": "86702643a5c3bdf74257ff6062535897129ed9144c4f5b70edfe338fef3e5c73",
      "node_type": "mdxjsEsm",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_4d1292be"
      }
    },
    {
      "segment_id": "53eaf0e1",
      "source_content": "Interceptors are execution middleware for various types of Ent queries. Contrary to hooks, interceptors are applied on\nthe read-path and implemented as interfaces, allows them to intercept and modify the query at different stages, providing\nmore fine-grained control over queries' behavior. For example, see the [Traverser interface](#defining-a-traverser) below.",
      "source_content_hash": "c42cebcf1beb56dd446f1a46c691b7b9fcee0cc596b343b677168b0666d81a7a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "拦截器（Interceptors）是用于各类Ent查询的执行中间件。与钩子（hooks）不同，拦截器作用于读取路径，通过接口实现方式允许在查询的不同阶段进行拦截和修改，从而提供对查询行为更细粒度的控制。例如，可参考下文所述的[Traverser接口](#defining-a-traverser)。"
      }
    },
    {
      "segment_id": "ba4f48ff",
      "source_content": "## Defining an Interceptor",
      "source_content_hash": "9da479b7edffdcb8bd5896bc1cc445c681d8007f3e2de11029d5500f09b5a874",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "## 定义拦截器"
      }
    },
    {
      "segment_id": "cf898102",
      "source_content": "To define an `Interceptor`, users can declare a struct that implements the `Intercept` method or use the predefined\n`ent.InterceptFunc` adapter.",
      "source_content_hash": "e3edb0298f35106774a9cee4e803b8bf63c7c79157a5362710075a36efea4fd3",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "要定义`Interceptor`，用户可以声明实现`Intercept`方法的结构体，或使用预定义的`ent.InterceptFunc`适配器。"
      }
    },
    {
      "segment_id": "6e5ba8fb",
      "source_content": "```go\nent.InterceptFunc(func(next ent.Querier) ent.Querier {\n\treturn ent.QuerierFunc(func(ctx context.Context, query ent.Query) (ent.Value, error) {\n\t\t// Do something before the query execution.\n\t\tvalue, err := next.Query(ctx, query)\n\t\t// Do something after the query execution.\n\t\treturn value, err\n\t})\n})\n```",
      "source_content_hash": "ec99edf80031cee744cb9c7b1105eb228b0fe8b4c75cf38e7d6702c201805e08",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_6e5ba8fb"
      }
    },
    {
      "segment_id": "4b1d2d7d",
      "source_content": "In the example above, the `ent.Query` represents a generated query builder (e.g., `ent.<T>Query`) and accessing its\nmethods requires type assertion. For example:",
      "source_content_hash": "ba8f69af78a8335c0277b2e9d11a6a0f2a603eb09afed03c3c4d9582a932623e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "上例中，`ent.Query`代表生成的查询构建器（如`ent.<T>Query`），访问其方法需要进行类型断言。例如："
      }
    },
    {
      "segment_id": "b017063d",
      "source_content": "```go\nent.InterceptFunc(func(next ent.Querier) ent.Querier {\n    return ent.QuerierFunc(func(ctx context.Context, query ent.Query) (ent.Value, error) {\n        if q, ok := query.(*ent.UserQuery); ok {\n            q.Where(user.Name(\"a8m\"))\n        }\n        return next.Query(ctx, query)\n    })\n})\n```",
      "source_content_hash": "9cb959b5ac5b1c39128512de567d56a239022188981e742984f83a4ed15a8fae",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_b017063d"
      }
    },
    {
      "segment_id": "1042b50d",
      "source_content": "However, the utilities generated by the `intercept` feature flag enable the creation of generic interceptors that can\nbe applied to any query type. The `intercept` feature flag can be added to a project in one of two ways:",
      "source_content_hash": "13082a59ba97e9f9c00171d596adc9a2c73fcd3cf686fb9b018ef837615403fd",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "但通过`intercept`特性标志生成的工具，可创建适用于任意查询类型的通用拦截器。该特性标志可通过以下两种方式添加到项目中："
      }
    },
    {
      "segment_id": "8bddee80",
      "source_content": "#### Configuration",
      "source_content_hash": "32b7e1ecb04ae1930f700245d8405fd5df25a3cf0ac942e6b289772e3fff97f7",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "#### 配置方式"
      }
    },
    {
      "segment_id": "2f83a0f4",
      "source_content": "<Tabs>\n<TabItem value=\"cli\" label=\"CLI\" default>\n\nIf you are using the default go generate config, add `--feature intercept` option to the `ent/generate.go` file as follows:\n\n```go title=\"ent/generate.go\"\npackage ent\n\n//go:generate go run -mod=mod entgo.io/ent/cmd/ent generate --feature intercept ./schema\n```\n\nIt is recommended to add the [`schema/snapshot`](features.md#auto-solve-merge-conflicts) feature-flag along with the\n`intercept` flag to enhance the development experience, for example:\n\n```go\n//go:generate go run -mod=mod entgo.io/ent/cmd/ent generate --feature intercept,schema/snapshot ./schema\n```\n\n</TabItem>\n<TabItem value=\"entc\" label=\"Go\">\n\nIf you are using the configuration from the GraphQL documentation, add the feature flag as follows:\n\n```go\n// +build ignore\n\npackage main\n\n\nimport (\n    \"log\"\n\n    \"entgo.io/ent/entc\"\n    \"entgo.io/ent/entc/gen\"\n)\n\nfunc main() {\n\topts := []entc.Option{\n        entc.FeatureNames(\"intercept\"),\n\t}\n    if err := entc.Generate(\"./schema\", &gen.Config{}, opts...); err != nil {\n\t\tlog.Fatalf(\"running ent codegen: %v\", err)\n\t}\n}\n```\n\n\nIt is recommended to add the [`schema/snapshot`](features.md#auto-solve-merge-conflicts) feature-flag along with the\n`intercept` flag to enhance the development experience, for example:\n\n```diff\nopts := []entc.Option{\n-    entc.FeatureNames(\"intercept\"),\n+    entc.FeatureNames(\"intercept\", \"schema/snapshot\"),\n}\n```\n\n</TabItem>\n</Tabs>",
      "source_content_hash": "afb1378d4a533ec4df18a89d2c408697c63fe8e4ae0a7ebf18e89a19664682e9",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_2f83a0f4"
      }
    },
    {
      "segment_id": "1f4b3b94",
      "source_content": "#### Interceptors Registration",
      "source_content_hash": "dc82c6cc1b3dd4db144f6d85f8d6e4bab2e1058febe4fbb720eed513b4f7bd1e",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "#### 拦截器注册"
      }
    },
    {
      "segment_id": "3faebbae",
      "source_content": ":::important\nYou should notice that similar to [schema hooks](hooks.md#hooks-registration), if you use the **`Interceptors`** option\nin your schema, you **MUST** add the following import in the main package, because a circular import is possible between\nthe schema package and the generated ent package:\n```go\nimport _ \"<project>/ent/runtime\"\n```\n:::",
      "source_content_hash": "bd8b137cfa363f9b9d396371e84348316365a323e5fde724291621d341ac87df",
      "node_type": "containerDirective",
      "translatable": true,
      "translations": {
        "zh-CN": ":::important\n需注意：与[模式钩子](hooks.md#hooks-registration)类似，若在模式中使用**`Interceptors`**选项，**必须**在主包中添加以下导入语句，以避免模式包与生成的ent包之间可能出现的循环引用：\n```go\nimport _ \"<project>/ent/runtime\"\n```\n:::"
      }
    },
    {
      "segment_id": "37fca32e",
      "source_content": "#### Using the generated `intercept` package",
      "source_content_hash": "ba2f11460bd2ac3f994980aaa6800647091b4d1d28ce0d76e525176bb85e0f94",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "#### 使用生成的`intercept`包"
      }
    },
    {
      "segment_id": "a8610918",
      "source_content": "Once the feature flag was added to your project, the creation of interceptors is possible using the `intercept` package:",
      "source_content_hash": "c905800e7b3d90145a206b69c2e248ba67fb860c34b0da7ba48cd67fd1327c2e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "添加特性标志后，即可使用`intercept`包创建拦截器："
      }
    },
    {
      "segment_id": "1f6cb4dd",
      "source_content": "<Tabs>\n<TabItem value=\"func\" label=\"intercept.Func\" default>\n\n```go\nclient.Intercept(\n\tintercept.Func(func(ctx context.Context, q intercept.Query) error {\n\t\t// Limit all queries to 1000 records.\n\t\tq.Limit(1000)\n\t\treturn nil\n\t})\n)\n```\n\n</TabItem>\n<TabItem value=\"traverse-func\" label=\"intercept.TraverseFunc\">\n\n```go\nclient.Intercept(\n\tintercept.TraverseFunc(func(ctx context.Context, q intercept.Query) error {\n        // Apply a predicate/filter to all queries.\n\t\tq.WhereP(predicate)\n\t\treturn nil\n\t})\n)\n```\n\n</TabItem>\n<TabItem value=\"new-query\" label=\"intercept.NewQuery\">\n\n```go\nent.InterceptFunc(func(next ent.Querier) ent.Querier {\n\treturn ent.QuerierFunc(func(ctx context.Context, query ent.Query) (ent.Value, error) {\n        // Get a generic query from a typed-query.\n\t\tq, err := intercept.NewQuery(query)\n        if err != nil {\n            return nil, err\n        }\n        q.Limit(1000)\n\t\treturn next.Intercept(ctx, query)\n\t})\n})\n```\n\n</TabItem>\n</Tabs>",
      "source_content_hash": "421173c6296d47a2018ad317d8d7173b5a6f7648a3413947dbd6d5caa35bfefc",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_1f6cb4dd"
      }
    },
    {
      "segment_id": "657bde08",
      "source_content": "## Defining a Traverser",
      "source_content_hash": "56083b9f6feda542f6603837882d1d80628101f9a32799c2fb843039751a0b16",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "## 定义遍历器（Traverser）"
      }
    },
    {
      "segment_id": "827eb9a3",
      "source_content": "In some cases, there is a need to intercept [graph traversals](traversals.md) and modify their builders before\ncontinuing to the nodes returned by the query. For example, in the query below, we want to ensure that only `active`\nusers are traversed in **any** graph traversals in the system:",
      "source_content_hash": "d6106ea6aace60ba4cde41acf2a8b8b42b20e39ea30f2ab958e1863ccd0eb88d",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "某些场景下，需要拦截[图遍历](traversals.md)并在查询返回节点前修改其构建器。例如在下述查询中，我们需要确保系统中**所有**图遍历仅处理`active`状态的用户："
      }
    },
    {
      "segment_id": "7eccd6ba",
      "source_content": "```go\nintercept.TraverseUser(func(ctx context.Context, q *ent.UserQuery) error {\n\tq.Where(user.Active(true))\n\treturn nil\n})\n```",
      "source_content_hash": "1e0d9508420d0fe910e48894f2ed3a2458c6e4364c30744016030db94104e2ae",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_7eccd6ba"
      }
    },
    {
      "segment_id": "9ef42155",
      "source_content": "After defining and registering such Traverser, it will take effect on all graph traversals in the system. For example:",
      "source_content_hash": "d3adff95bf93995c799a79f3bda3154416177549f42c6ae22bbf623c5c6936bc",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "定义并注册此类遍历器后，将对系统中所有图遍历生效。例如："
      }
    },
    {
      "segment_id": "8185786b",
      "source_content": "```go\nfunc TestTypedTraverser(t *testing.T) {\n\tctx := context.Background()\n\tclient := enttest.Open(t, dialect.SQLite, \"file:ent?mode=memory&_fk=1\")\n\tdefer client.Close()\n\ta8m, nat := client.User.Create().SetName(\"a8m\").SaveX(ctx), client.User.Create().SetName(\"nati\").SetActive(false).SaveX(ctx)\n\tclient.Pet.CreateBulk(\n\t\tclient.Pet.Create().SetName(\"a\").SetOwner(a8m),\n\t\tclient.Pet.Create().SetName(\"b\").SetOwner(a8m),\n\t\tclient.Pet.Create().SetName(\"c\").SetOwner(nat),\n\t).ExecX(ctx)\n\n    // highlight-start\n\t// Get pets of all users.\n\tif n := client.User.Query().QueryPets().CountX(ctx); n != 3 {\n\t\tt.Errorf(\"got %d pets, want 3\", n)\n\t}\n    // highlight-end\n\n\t// Add an interceptor that filters out inactive users.\n\tclient.User.Intercept(\n\t\tintercept.TraverseUser(func(ctx context.Context, q *ent.UserQuery) error {\n\t\t\tq.Where(user.Active(true))\n\t\t\treturn nil\n\t\t}),\n\t)\n\n    // highlight-start\n\t// Only pets of active users are returned.\n\tif n := client.User.Query().QueryPets().CountX(ctx); n != 2 {\n\t\tt.Errorf(\"got %d pets, want 2\", n)\n\t}\n    // highlight-end\n}\n```",
      "source_content_hash": "75119d478c4922d84422ef2ec1400927482e2369487b3352caadaf980dd77a88",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_8185786b"
      }
    },
    {
      "segment_id": "dc825187",
      "source_content": "## Interceptors vs. Traversers",
      "source_content_hash": "138960a8068fc996bb186bb1d96558e4f66097d707d36ded3b0ffffed8471a5c",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "## 拦截器与遍历器的区别"
      }
    },
    {
      "segment_id": "833ce577",
      "source_content": "Both `Interceptors` and `Traversers` can be used to modify the behavior of queries, but they do so at different stages\nthe execution. Interceptors function as middleware and allow modifying the query before it is executed and modifying\nthe records after they are returned from the database. For this reason, they are applied only in the final stage of the\nquery - during the actual execution of the statement on the database. On the other hand, Traversers are called one stage\nearlier, at each step of a graph traversal allowing them to modify both intermediate and final queries before they\nare joined together.",
      "source_content_hash": "e6676b5c32a2a7fb4ec43c3d86eb71ef818cef19cad05a61bf1cc9ee8c368e02",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "`Interceptors`和`Traversers`均可用于修改查询行为，但作用于不同执行阶段。拦截器作为中间件，允许在查询执行前修改查询语句，并在数据库返回记录后修改结果集，因此仅作用于查询的最终阶段——即实际执行数据库语句时。而遍历器在更早阶段调用，可在图遍历的每一步中修改中间查询和最终查询，然后才将它们组合起来。"
      }
    },
    {
      "segment_id": "01902900",
      "source_content": "In summary, a Traverse function is a better fit for adding default filters to graph traversals while using an Intercept\nfunction is better for implementing logging or caching capabilities to the application.",
      "source_content_hash": "714a663ec80591231d51fb4183d432445e258521fe5ceb19822c30fd74e224d0",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "总结而言，Traverse函数更适合为图遍历添加默认过滤器，而Intercept函数更适合实现应用的日志记录或缓存功能。"
      }
    },
    {
      "segment_id": "7b2a4831",
      "source_content": "```go\nclient.User.Query().\n    QueryGroups().\t// User traverse functions applied.\n    QueryPosts().\t// Group traverse functions applied.\n    All(ctx)\t    // Post traverse and intercept functions applied.\n```",
      "source_content_hash": "8217c0243b00a82d493150ded63ae4a1776b7ec9a36ce2f064f68acecd4110ad",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_7b2a4831"
      }
    },
    {
      "segment_id": "7eac7922",
      "source_content": "## Examples",
      "source_content_hash": "0d19ab46319785768005536313f02bd3b9b779aaed82eeac5bf7a7f796ad3ef1",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "## 示例"
      }
    },
    {
      "segment_id": "c9f45ca3",
      "source_content": "### Soft Delete",
      "source_content_hash": "01632757711b741a7f3a8efd62be44061b26b8e4d07fcccba434318d1ee50512",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "### 软删除"
      }
    },
    {
      "segment_id": "f211c69a",
      "source_content": "The soft delete pattern is a common use-case for interceptors and hooks. The example below demonstrates how to add such\nfunctionality to all schemas in the project using [`ent.Mixin`](schema-mixin.md):",
      "source_content_hash": "2225171d2af56675762da0cc79c2cf779dc48c4bf0e2c9fb2629640670ee9f2a",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "软删除模式是拦截器与钩子的典型用例。以下示例展示如何通过[`ent.Mixin`](schema-mixin.md)为项目中所有模式添加该功能："
      }
    },
    {
      "segment_id": "d638060b",
      "source_content": "<Tabs>\n<TabItem value=\"mixin\" label=\"Mixin\" default>\n\n```go\n// SoftDeleteMixin implements the soft delete pattern for schemas.\ntype SoftDeleteMixin struct {\n\tmixin.Schema\n}\n\n// Fields of the SoftDeleteMixin.\nfunc (SoftDeleteMixin) Fields() []ent.Field {\n\treturn []ent.Field{\n\t\tfield.Time(\"delete_time\").\n\t\t\tOptional(),\n\t}\n}\n\ntype softDeleteKey struct{}\n\n// SkipSoftDelete returns a new context that skips the soft-delete interceptor/mutators.\nfunc SkipSoftDelete(parent context.Context) context.Context {\n\treturn context.WithValue(parent, softDeleteKey{}, true)\n}\n\n// Interceptors of the SoftDeleteMixin.\nfunc (d SoftDeleteMixin) Interceptors() []ent.Interceptor {\n\treturn []ent.Interceptor{\n\t\tintercept.TraverseFunc(func(ctx context.Context, q intercept.Query) error {\n\t\t\t// Skip soft-delete, means include soft-deleted entities.\n\t\t\tif skip, _ := ctx.Value(softDeleteKey{}).(bool); skip {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\td.P(q)\n\t\t\treturn nil\n\t\t}),\n\t}\n}\n\n// Hooks of the SoftDeleteMixin.\nfunc (d SoftDeleteMixin) Hooks() []ent.Hook {\n\treturn []ent.Hook{\n\t\thook.On(\n\t\t\tfunc(next ent.Mutator) ent.Mutator {\n\t\t\t\treturn ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) {\n\t\t\t\t\t// Skip soft-delete, means delete the entity permanently.\n\t\t\t\t\tif skip, _ := ctx.Value(softDeleteKey{}).(bool); skip {\n\t\t\t\t\t\treturn next.Mutate(ctx, m)\n\t\t\t\t\t}\n\t\t\t\t\tmx, ok := m.(interface {\n\t\t\t\t\t\tSetOp(ent.Op)\n\t\t\t\t\t\tClient() *gen.Client\n\t\t\t\t\t\tSetDeleteTime(time.Time)\n\t\t\t\t\t\tWhereP(...func(*sql.Selector))\n\t\t\t\t\t})\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"unexpected mutation type %T\", m)\n\t\t\t\t\t}\n\t\t\t\t\td.P(mx)\n\t\t\t\t\tmx.SetOp(ent.OpUpdate)\n\t\t\t\t\tmx.SetDeleteTime(time.Now())\n\t\t\t\t\treturn mx.Client().Mutate(ctx, m)\n\t\t\t\t})\n\t\t\t},\n\t\t\tent.OpDeleteOne|ent.OpDelete,\n\t\t),\n\t}\n}\n\n// P adds a storage-level predicate to the queries and mutations.\nfunc (d SoftDeleteMixin) P(w interface{ WhereP(...func(*sql.Selector)) }) {\n\tw.WhereP(\n\t\tsql.FieldIsNull(d.Fields()[0].Descriptor().Name),\n\t)\n}\n```\n\n</TabItem>\n<TabItem value=\"schema\" label=\"Mixin usage\">\n\n```go\n// Pet holds the schema definition for the Pet entity.\ntype Pet struct {\n\tent.Schema\n}\n\n// Mixin of the Pet.\nfunc (Pet) Mixin() []ent.Mixin {\n\treturn []ent.Mixin{\n        //highlight-next-line\n\t\tSoftDeleteMixin{},\n\t}\n}\n```\n\n</TabItem>\n<TabItem value=\"runtime\" label=\"Runtime usage\">\n\n```go\n// Filter out soft-deleted entities.\npets, err := client.Pet.Query().All(ctx)\nif err != nil {\n    return err\n}\n\n// Include soft-deleted entities.\npets, err := client.Pet.Query().All(schema.SkipSoftDelete(ctx))\nif err != nil {\n    return err\n}\n```\n\n</TabItem>\n</Tabs>",
      "source_content_hash": "74b307b7b0b31c72355725b50675830a784885a964985512cdfa2b5132ff53b8",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_d638060b"
      }
    },
    {
      "segment_id": "d67910b8",
      "source_content": "### Limit number of records",
      "source_content_hash": "6b16cbc645f56d26154c831239c9f11526bfb5274f83483826606d9e4cce3411",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "### 限制记录数量"
      }
    },
    {
      "segment_id": "b6abd1ad",
      "source_content": "The following example demonstrates how to limit the number of records returned from the database using an interceptor\nfunction:",
      "source_content_hash": "784a4451b9a830f93ec6370231bb6de5aa4e75c213546b7408b86f0af5ba4386",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "以下示例演示如何使用拦截器函数限制数据库返回的记录数量："
      }
    },
    {
      "segment_id": "950ee0de",
      "source_content": "```go\nclient.Intercept(\n    intercept.Func(func(ctx context.Context, q intercept.Query) error {\n\t\t// LimitInterceptor limits the number of records returned from\n\t\t// the database to 1000, in case Limit was not explicitly set.\n\t\tif ent.QueryFromContext(ctx).Limit == nil {\n\t\t\tq.Limit(1000)\n\t\t}\n\t\treturn nil\n\t}),\n)\n```",
      "source_content_hash": "b4f0640b721d7082fc5bfebc0463bccf7ace34da52c920f61ff9816f25dee6b9",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_950ee0de"
      }
    },
    {
      "segment_id": "c713fcdf",
      "source_content": "### Multi-project support",
      "source_content_hash": "966bdc7340088dbeea54cf7a890a0d3e9872e57a5f22c12824903a359ddf7f4a",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "### 多项目支持"
      }
    },
    {
      "segment_id": "ebea2db8",
      "source_content": "The example below demonstrates how to write a generic interceptor that can be used in multiple projects:",
      "source_content_hash": "7d59ef3d8cfb4db67af5aa3c449e4b8a8f6f02b5113307d88cfc7fa9fc6258d7",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "以下示例展示了如何编写一个可在多个项目中复用的通用拦截器："
      }
    },
    {
      "segment_id": "cf83732b",
      "source_content": "<Tabs>\n<TabItem value=\"definition\" label=\"Definition\">\n\n```go\n// Project-level example. The usage of \"entgo\" package emphasizes that this interceptor does not rely on any generated code.\nfunc SharedLimiter[Q interface{ Limit(int) }](f func(entgo.Query) (Q, error), limit int) entgo.Interceptor {\n\treturn entgo.InterceptFunc(func(next entgo.Querier) entgo.Querier {\n\t\treturn entgo.QuerierFunc(func(ctx context.Context, query entgo.Query) (entgo.Value, error) {\n\t\t\tl, err := f(query)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tl.Limit(limit)\n\t\t\t// LimitInterceptor limits the number of records returned from the\n\t\t\t// database to the configured one, in case Limit was not explicitly set.\n\t\t\tif entgo.QueryFromContext(ctx).Limit == nil {\n\t\t\t\tl.Limit(limit)\n\t\t\t}\n\t\t\treturn next.Query(ctx, query)\n\t\t})\n\t})\n}\n```\n\n</TabItem>\n<TabItem value=\"usage\" label=\"Usage\">\n\n```go\nclient1.Intercept(SharedLimiter(intercept1.NewQuery, limit))\n\nclient2.Intercept(SharedLimiter(intercept2.NewQuery, limit))\n```\n\n</TabItem>\n</Tabs>",
      "source_content_hash": "14af5a05ca9691eb8197a3706f2845932fd0e2c53832cb42b751d90461c28adb",
      "node_type": "mdxJsxFlowElement",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_cf83732b"
      }
    }
  ],
  "target_i18n_subpath": "docusaurus-plugin-content-docs/current/interceptors.mdx",
  "last_updated_timestamp": "2025-06-05T15:16:18.653084+00:00",
  "schema_version": "1.0",
  "translated_versions": {
    "zh-CN": "1da431faf4c72d2f4c10d7a3ac6f1e50dd7d67f216e1113328056b0d0ace0c72"
  }
}