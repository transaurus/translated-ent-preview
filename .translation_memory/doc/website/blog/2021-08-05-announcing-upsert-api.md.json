{
  "source_file_path_relative_to_docusaurus_root": "blog/2021-08-05-announcing-upsert-api.md",
  "source_file_content_hash": "8deddfc21a14d13ad6079f68d9dd5cdd6150873b88f1211dbaad8c56edf850cc",
  "segments": [
    {
      "segment_id": "58cfcc64",
      "source_content": "---\ntitle: Announcing the Upsert API in v0.9.0\nauthor: Rotem Tamir\nauthorURL: \"https://github.com/rotemtam\"\nauthorImageURL: \"https://s.gravatar.com/avatar/36b3739951a27d2e37251867b7d44b1a?s=80\"\nauthorTwitter: _rtam\n---",
      "source_content_hash": "270e912908bcecbca31f536d1410bef07b7e9f8280bf25421ba241082d520e7a",
      "node_type": "yaml",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_58cfcc64"
      }
    },
    {
      "segment_id": "7e5c5a39",
      "source_content": "It has been almost 4 months since our [last release](https://github.com/ent/ent/releases/tag/v0.8.0), and for a good reason.\nVersion [0.9.0](https://github.com/ent/ent/releases/tag/v0.9.0) which was released today is packed with some highly-anticipated\nfeatures. Perhaps at the top of the list, is a feature that has been in discussion for [more than a year in a half](https://github.com/ent/ent/issues/139)\nand was one of the most commonly requested features in the [Ent User Survey](https://forms.gle/7VZSPVc7D1iu75GV9): the Upsert API!",
      "source_content_hash": "f3811493431a823332e5bd100d37b1e1557f0839f1543d25212c78e1af3d3d05",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "距离我们[上一个版本](https://github.com/ent/ent/releases/tag/v0.8.0)发布已近四个月，而今天的[0.9.0版本](https://github.com/ent/ent/releases/tag/v0.9.0)确实值得等待——它包含了多项备受期待的功能。其中最引人注目的，是经过[一年半讨论](https://github.com/ent/ent/issues/139)且位列[Ent用户调查](https://forms.gle/7VZSPVc7D1iu75GV9)需求榜首的Upsert API！"
      }
    },
    {
      "segment_id": "cf898102",
      "source_content": "Version 0.9.0 adds support for \"Upsert\" style statements using [a new feature flag](https://entgo.io/docs/feature-flags#upsert): `sql/upsert`. \nEnt has a [collection of feature flags](https://entgo.io/docs/feature-flags) that can be switched on to add more features\nto the code generated by Ent. This is used as both a mechanism to allow opt-in to some features that are not necessarily\ndesired in every project and as a way to run experiments of features that may one day become part of Ent's core.",
      "source_content_hash": "b2806a197b1d0a05d69170361fff857bcd38e64f0a2224bd2ec17b1e05343575",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "0.9.0版本通过[新特性标志](https://entgo.io/docs/feature-flags#upsert)`sql/upsert`实现了\"Upsert\"式语句支持。Ent提供了一系列[特性标志](https://entgo.io/docs/feature-flags)，开发者可选择性启用这些标志来扩展Ent生成的代码功能。这既是一种允许按需选择非必要功能的机制，也是试验未来可能成为Ent核心功能的途径。"
      }
    },
    {
      "segment_id": "1acb9a05",
      "source_content": "In this post, we will introduce the new feature, the places where it is useful, and demonstrate how to use it.",
      "source_content_hash": "f30b9fddd80477b8442e782e7828c02e0f30ba8c8bc2dd034888f7cdd420f705",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "本文将介绍这一新特性、其适用场景及具体使用方法。"
      }
    },
    {
      "segment_id": "63622bf0",
      "source_content": "### Upsert",
      "source_content_hash": "53ea181f9cdc4608ca7ca10c309e1354a4e7d140026b6e52dac3212076fb6777",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "### Upsert原理"
      }
    },
    {
      "segment_id": "98cfbd53",
      "source_content": "\"Upsert\" is a commonly-used term in data systems that is a portmanteau of \"update\" and \"insert\" which usually refers to\na statement that attempts to insert a record to a table, and if a uniqueness constraint is violated (e.g. a record by\nthat ID already exists) that record is updated instead. While none of the popular relational databases have a specific\n`UPSERT` statement, most of them support ways of achieving this type of behavior.",
      "source_content_hash": "82e1fa263490f42533c1be40a5e78ecdd7f0ea4bec06b824f1b62bd66c9a0d6d",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "\"Upsert\"是数据系统中常用的合成词，由\"update\"和\"insert\"组合而成，通常指尝试插入记录时若违反唯一性约束（如ID已存在），则转为更新现有记录的语句。虽然主流关系型数据库没有专门的`UPSERT`语句，但大多支持实现此类行为的方式。"
      }
    },
    {
      "segment_id": "4b1d2d7d",
      "source_content": "For example, assume we have a table with this definition in an SQLite database:",
      "source_content_hash": "6eeeeb468fb5bcac510deb6933e5837270f29e03b63e4fcec36194c26aeea486",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "例如，假设我们在SQLite数据库中有如下表定义："
      }
    },
    {
      "segment_id": "cb57d798",
      "source_content": "```sql\nCREATE TABLE users (\n   id integer PRIMARY KEY AUTOINCREMENT,\n   email varchar(255) UNIQUE,\n   name varchar(255)\n)\n```",
      "source_content_hash": "a12b65d740846bcf6a37a160676b22e6c99a2cd2e5d02fa6a5630acd905fe453",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_cb57d798"
      }
    },
    {
      "segment_id": "c3a738de",
      "source_content": "If we try to execute the same insert twice:",
      "source_content_hash": "39fd70650b607c996dfea2c089b01376f9a0b4d97131c4b80ab9cdc9fb02a72d",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "若尝试重复执行相同插入："
      }
    },
    {
      "segment_id": "bca33820",
      "source_content": "```sql\nINSERT INTO users (email, name) VALUES ('rotem@entgo.io', 'Rotem Tamir');\nINSERT INTO users (email, name) VALUES ('rotem@entgo.io', 'Rotem Tamir');\n```",
      "source_content_hash": "85d045ab976e0a79a4a16e812bb17b06b315f709ba58ccd8e6fc171225908c2c",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_bca33820"
      }
    },
    {
      "segment_id": "8af76f3d",
      "source_content": "We get this error:",
      "source_content_hash": "f3083a5214a0da1a17f31995cc8633e5252e5b8314750bb63e7f62d9dc9e1aeb",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "将得到错误："
      }
    },
    {
      "segment_id": "48ec8149",
      "source_content": "```\n[2021-08-05 06:49:22] UNIQUE constraint failed: users.email\n```",
      "source_content_hash": "c19d4e7698a0fc7abea9247231064ed16a7f4771b21873d940c323a920181bfe",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_48ec8149"
      }
    },
    {
      "segment_id": "f7ef78f9",
      "source_content": "In many cases, it is useful to have write operations be [idempotent](https://en.wikipedia.org/wiki/Idempotence),\nmeaning we can run them many times in a row while leaving the system in the same state.",
      "source_content_hash": "2ec90d027ce3f6b24d4124eaad7b56e8c036978929293850785fe9e05b18dd82",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "许多场景下，我们需要写操作具备[幂等性](https://en.wikipedia.org/wiki/Idempotence)——即多次执行后系统状态保持一致。"
      }
    },
    {
      "segment_id": "d3649a1e",
      "source_content": "In other cases, it is not desirable to query if a record exists before trying to create it. For these kinds of situations,\nSQLite supports the [`ON CONFLICT` clause](https://www.sqlite.org/lang_upsert.html) in `INSERT`\nstatements. To instruct SQLite to override an existing value with the new one we can execute:",
      "source_content_hash": "eb64af0d553d9abf859d526e506bfdccb5154e88d6d6bd4cdf3623a7e0e97d77",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "另一些场景中，我们不希望在创建记录前先查询其是否存在。针对这类需求，SQLite支持在`INSERT`语句中使用[`ON CONFLICT`子句](https://www.sqlite.org/lang_upsert.html)。若需用新值覆盖现有记录，可执行："
      }
    },
    {
      "segment_id": "6d254e09",
      "source_content": "```sql\nINSERT INTO users (email, name) values ('rotem@entgo.io', 'Tamir, Rotem')\nON CONFLICT (email) DO UPDATE SET email=excluded.email, name=excluded.name;\n```",
      "source_content_hash": "c7a0b7613ee22b4cec88d782295cb1e613c2ff665be1019caa74abba31561da7",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_6d254e09"
      }
    },
    {
      "segment_id": "79ad944d",
      "source_content": "If we prefer to keep the existing values, we can use the `DO NOTHING` conflict action:",
      "source_content_hash": "c9bfd980c3772921883b8b522fbd2302a8277251a7e1ef8d0ee50d1ab96d99b0",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "若需保留现有值，可使用`DO NOTHING`冲突操作："
      }
    },
    {
      "segment_id": "5d4925eb",
      "source_content": "```sql\nINSERT INTO users (email, name) values ('rotem@entgo.io', 'Tamir, Rotem') \nON CONFLICT DO NOTHING;\n```",
      "source_content_hash": "45d9e56bfaa18dc5f46d943ea937ff5c69a748c16daa9f9bebae81e63c728a64",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_5d4925eb"
      }
    },
    {
      "segment_id": "e7772088",
      "source_content": "Sometimes we want to merge the two versions in some way, we can use the `DO UPDATE` action a little differently to\nachieve do something like:",
      "source_content_hash": "107a0628971fb3cea5ccb65add1ee0eb11e1aea11f3cccf03f530b6d23447dc4",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "有时我们需要以某种方式合并两个版本，可通过特殊形式的`DO UPDATE`实现类似操作："
      }
    },
    {
      "segment_id": "af983f82",
      "source_content": "```sql\nINSERT INTO users (email, full_name) values ('rotem@entgo.io', 'Tamir, Rotem') \nON CONFLICT (email) DO UPDATE SET name=excluded.name ||  ' (formerly: ' || users.name || ')'\n```",
      "source_content_hash": "21007337f4d5e376e4afda56a5551afd388b4dbd2da6347d668945a2a12c7f48",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_af983f82"
      }
    },
    {
      "segment_id": "e8e162a9",
      "source_content": "In this case, after our second `INSERT` the value for the `name` column would be: `Tamir, Rotem (formerly: Rotem Tamir)`.\nNot very useful, but hopefully you can see that you can do cool things this way.",
      "source_content_hash": "413c98dcf131835716913642e646d20482e4acaaba04f261f071710fecd8a1c4",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "此例中，第二次`INSERT`后`name`列的值将变为：`Tamir, Rotem (原值: Rotem Tamir)`。虽不实用，但足以展示该机制的灵活性。"
      }
    },
    {
      "segment_id": "8a9b6c26",
      "source_content": "### Upsert with Ent",
      "source_content_hash": "53267239bb8d5dd51f061ce0be955049f0197fd9942590a541fed3634ee58aea",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "### Ent中的Upsert实现"
      }
    },
    {
      "segment_id": "a1fa5396",
      "source_content": "Assume we have an existing Ent project with an entity similar to the `users` table described above:",
      "source_content_hash": "2a8004a96ce7c8104920b351439ba5fc4cbc2d2d97778c3af36e6a079b643fb3",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "假设已有Ent项目包含类似前文`users`表的实体："
      }
    },
    {
      "segment_id": "8c3563d3",
      "source_content": "```go\n// User holds the schema definition for the User entity.\ntype User struct {\n\tent.Schema\n}\n\n// Fields of the User.\nfunc (User) Fields() []ent.Field {\n\treturn []ent.Field{\n\t\tfield.String(\"email\").\n\t\t\tUnique(),\n\t\tfield.String(\"name\"),\n\t}\n}\n```",
      "source_content_hash": "52555905d913e2d7f741d48f352d7b144a261e2741bc71af06f05d309abc7b5b",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_8c3563d3"
      }
    },
    {
      "segment_id": "6ca4479f",
      "source_content": "As the Upsert API is a newly released feature, make sure to update your `ent` version using:",
      "source_content_hash": "43d40dcacf5aca58525603ed0e8dfb52194feb94ba1437a389bf1a3f49ce3ca9",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "由于Upsert API是新发布的功能，请先通过以下命令更新`ent`版本："
      }
    },
    {
      "segment_id": "1cf51900",
      "source_content": "```bash\ngo get -u entgo.io/ent@v0.9.0\n```",
      "source_content_hash": "626a9a35d085069f3691c14a8330468154943e2f68cd9b74c7a30c7df09a8e13",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_1cf51900"
      }
    },
    {
      "segment_id": "f0984c2a",
      "source_content": "Next, add the `sql/upsert` feature flag to your code-generation flags, in `ent/generate.go`:",
      "source_content_hash": "8d30f6a3cef4d61267ad974efa89ad69b86dd82d68d855d271a2c2b49c596f1e",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "接着在代码生成标志中添加`sql/upsert`特性标志，修改`ent/generate.go`文件："
      }
    },
    {
      "segment_id": "7ded566f",
      "source_content": "```go\npackage ent\n\n//go:generate go run -mod=mod entgo.io/ent/cmd/ent generate --feature sql/upsert ./schema\n```",
      "source_content_hash": "1dc7a19741ece9621c2d2319f7dd2f5e5da1fb7840d64d7a6d7ae8fe0f31a225",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_7ded566f"
      }
    },
    {
      "segment_id": "d21af28f",
      "source_content": "Next, re-run code generation for your project:",
      "source_content_hash": "a6876ee284b79f307e8c9643c282a85953eb897b3517be5e6d411ac9ebc3664b",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "最后重新执行项目代码生成："
      }
    },
    {
      "segment_id": "5347a9b5",
      "source_content": "```go\ngo generate ./...\n```",
      "source_content_hash": "ff67700702d4a011fb30a9ff30165ebf5e30d36e869b54cd41cc839284c467af",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_5347a9b5"
      }
    },
    {
      "segment_id": "558df877",
      "source_content": "Observe that a new method named `OnConflict` was added to the `ent/user_create.go` file:",
      "source_content_hash": "77141c83468c4bbfdc22b15bf61bbbf2849a2573f2cc06fa6c2be05e47e59fe3",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "注意在`ent/user_create.go`文件中新增了一个名为`OnConflict`的方法："
      }
    },
    {
      "segment_id": "6f605d92",
      "source_content": "```go\n// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause\n// of the `INSERT` statement. For example:\n//\n//\tclient.User.Create().\n//\t\tSetEmailAddress(v).\n//\t\tOnConflict(\n//\t\t\t// Update the row with the new values\n//\t\t\t// the was proposed for insertion.\n//\t\t\tsql.ResolveWithNewValues(),\n//\t\t).\n//\t\t// Override some of the fields with custom\n//\t\t// update values.\n//\t\tUpdate(func(u *ent.UserUpsert) {\n//\t\t\tSetEmailAddress(v+v)\n//\t\t}).\n//\t\tExec(ctx)\n//\nfunc (uc *UserCreate) OnConflict(opts ...sql.ConflictOption) *UserUpsertOne {\n\tuc.conflict = opts\n\treturn &UserUpsertOne{\n\t\tcreate: uc,\n\t}\n}\n```",
      "source_content_hash": "4cce947ec8d1c17636458a327441f0521d29661e2f801c4c3d8a250fef824161",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_6f605d92"
      }
    },
    {
      "segment_id": "17b50e81",
      "source_content": "This (along with more new generated code) will serve us in achieving upsert behavior for our `User` entity.\nTo explore this, let's first start by writing a test to reproduce the uniqueness constraint error:",
      "source_content_hash": "385df8f714c63629936c793adf6b517bd0272a2912a1a1c25d444a39061591a8",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "该方法（连同其他新生成的代码）将帮助我们为`User`实体实现upsert行为。为了验证这一点，我们首先编写一个测试来复现唯一性约束错误："
      }
    },
    {
      "segment_id": "cf5bbc3b",
      "source_content": "```go\nfunc TestUniqueConstraintFails(t *testing.T) {\n\tclient := enttest.Open(t, \"sqlite3\", \"file:ent?mode=memory&cache=shared&_fk=1\")\n\tctx := context.TODO()\n\n\t// Create the user for the first time.\n\tclient.User.\n\t\tCreate().\n\t\tSetEmail(\"rotem@entgo.io\").\n\t\tSetName(\"Rotem Tamir\").\n\t\tSaveX(ctx)\n\n\t// Try to create a user with the same email the second time.\n\t_, err := client.User.\n\t\tCreate().\n\t\tSetEmail(\"rotem@entgo.io\").\n\t\tSetName(\"Rotem Tamir\").\n\t\tSave(ctx)\n\n\tif !ent.IsConstraintError(err) {\n\t\tlog.Fatalf(\"expected second created to fail with constraint error\")\n\t}\n\tlog.Printf(\"second query failed with: %v\", err)\n}\n```",
      "source_content_hash": "889a191c4305cd1d16395abe68e2e73e435ee09e18450a643e22d59dc89d9f86",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_cf5bbc3b"
      }
    },
    {
      "segment_id": "61a78cbe",
      "source_content": "The test passes:",
      "source_content_hash": "39e6ac2d870f9812845a9a48d04b04a2142c3f95c4af0622bcfbb2c7e1a59543",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "测试通过："
      }
    },
    {
      "segment_id": "904df6eb",
      "source_content": "```bash\n=== RUN   TestUniqueConstraintFails\n2021/08/05 07:12:11 second query failed with: ent: constraint failed: insert node to table \"users\": UNIQUE constraint failed: users.email\n--- PASS: TestUniqueConstraintFails (0.00s)\n```",
      "source_content_hash": "9f3ca0b437079519cc6907b72eceebc35572c84e19b7d6b3f976090df059b313",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_904df6eb"
      }
    },
    {
      "segment_id": "4e2e17c5",
      "source_content": "Next, let's see how to instruct Ent to override the existing values with the new in case a conflict occurs:",
      "source_content_hash": "4e28db4e979a561900fa2d722523e592a195086d6e173be88c55752e67eb33c0",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "接下来，我们演示如何配置Ent在发生冲突时用新值覆盖现有记录："
      }
    },
    {
      "segment_id": "bea1601a",
      "source_content": "```go\nfunc TestUpsertReplace(t *testing.T) {\n\tclient := enttest.Open(t, \"sqlite3\", \"file:ent?mode=memory&cache=shared&_fk=1\")\n\tctx := context.TODO()\n\n\t// Create the user for the first time.\n\torig := client.User.\n\t\tCreate().\n\t\tSetEmail(\"rotem@entgo.io\").\n\t\tSetName(\"Rotem Tamir\").\n\t\tSaveX(ctx)\n\n\t// Try to create a user with the same email the second time.\n\t// This time we set ON CONFLICT behavior, and use the `UpdateNewValues`\n\t// modifier.\n\tnewID := client.User.Create().\n\t\tSetEmail(\"rotem@entgo.io\").\n\t\tSetName(\"Tamir, Rotem\").\n\t\tOnConflict().\n\t\tUpdateNewValues().\n\t\t// we use the IDX method to receive the ID\n\t\t// of the created/updated entity\n\t\tIDX(ctx)\n\n\t// We expect the ID of the originally created user to be the same as\n\t// the one that was just updated.\n\tif orig.ID != newID {\n\t\tlog.Fatalf(\"expected upsert to update an existing record\")\n\t}\n\n\tcurrent := client.User.GetX(ctx, orig.ID)\n\tif current.Name != \"Tamir, Rotem\" {\n\t\tlog.Fatalf(\"expected upsert to replace with the new values\")\n\t}\n}\n```",
      "source_content_hash": "b2984123fdde33f331540019766cb716ec39c3ba2457ddd249e37ce5eda35c71",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_bea1601a"
      }
    },
    {
      "segment_id": "61e5dad6",
      "source_content": "Running our test:",
      "source_content_hash": "606c95a7afb362cd1db185f8a61e94b492251e7b2ada33327046e008a0d48479",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "运行测试："
      }
    },
    {
      "segment_id": "18e3e63d",
      "source_content": "```bash\n=== RUN   TestUpsertReplace\n--- PASS: TestUpsertReplace (0.00s)\n```",
      "source_content_hash": "2ec9f61ae8c6deff85b49aa8aa7280883f3c617823b3eca0f094321390b04e7d",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_18e3e63d"
      }
    },
    {
      "segment_id": "09d52457",
      "source_content": "Alternatively, we can use the `Ignore` modifier to instruct Ent to keep the old version when resolving the conflict.\nLet's write a test that shows this:",
      "source_content_hash": "55edd67c54e1e16099af2bcfb7118a6347a18bd14bd4a30c660628c92f30be12",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "或者，我们可以使用`Ignore`修饰符让Ent在冲突时保留原有记录。编写测试如下："
      }
    },
    {
      "segment_id": "d1a6eaaa",
      "source_content": "```go\nfunc TestUpsertIgnore(t *testing.T) {\n\tclient := enttest.Open(t, \"sqlite3\", \"file:ent?mode=memory&cache=shared&_fk=1\")\n\tctx := context.TODO()\n\n\t// Create the user for the first time.\n\torig := client.User.\n\t\tCreate().\n\t\tSetEmail(\"rotem@entgo.io\").\n\t\tSetName(\"Rotem Tamir\").\n\t\tSaveX(ctx)\n\n\t// Try to create a user with the same email the second time.\n\t// This time we set ON CONFLICT behavior, and use the `Ignore`\n\t// modifier.\n\tclient.User.\n\t\tCreate().\n\t\tSetEmail(\"rotem@entgo.io\").\n\t\tSetName(\"Tamir, Rotem\").\n\t\tOnConflict().\n\t\tIgnore().\n\t\tExecX(ctx)\n\n\tcurrent := client.User.GetX(ctx, orig.ID)\n\tif current.FullName != orig.FullName {\n\t\tlog.Fatalf(\"expected upsert to keep the original version\")\n\t}\n}\n```",
      "source_content_hash": "43a180f70a7a0be6614f6428ae9d5fbd0f19d8947e37588100b8692a0f51d970",
      "node_type": "code",
      "translatable": false,
      "translations": {
        "zh-CN": "@@untranslatable_placeholder_d1a6eaaa"
      }
    },
    {
      "segment_id": "12bc7444",
      "source_content": "You can read more about the feature in the [Feature Flag](https://entgo.io/docs/feature-flags#upsert) or [Upsert API](https://entgo.io/docs/crud#upsert-one) documentation.",
      "source_content_hash": "507b7ad41f2911e3391730f3f970d532dcd06d88c516100b3826349f78a9ca85",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "更多功能细节可查阅[特性标志](https://entgo.io/docs/feature-flags#upsert)或[Upsert API](https://entgo.io/docs/crud#upsert-one)文档。"
      }
    },
    {
      "segment_id": "b1889ce8",
      "source_content": "### Wrapping Up",
      "source_content_hash": "6df1295c536bdf3cf58241755891051d109001c784cced5b33a00f70983bc553",
      "node_type": "heading",
      "translatable": true,
      "translations": {
        "zh-CN": "### 总结"
      }
    },
    {
      "segment_id": "30aa9816",
      "source_content": "In this post, we presented the Upsert API, a long-anticipated capability, that is available by feature-flag in Ent v0.9.0.\nWe discussed where upserts are commonly used in applications and the way they are implemented using common relational databases.\nFinally, we showed a simple example of how to get started with the Upsert API using Ent.",
      "source_content_hash": "13ca3c667ec12392d17c32e24185b0a62aca32e5d17a32a7fedbfa560d4567c1",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "本文介绍了Ent v0.9.0通过特性标志提供的Upsert API——这个备受期待的功能。我们探讨了upsert在应用中的常见场景及其在关系型数据库中的实现原理，最后通过简单示例演示了如何在Ent中使用该API。"
      }
    },
    {
      "segment_id": "216a8ee1",
      "source_content": "Have questions? Need help with getting started? Feel free to join our [Discord server](https://discord.gg/qZmPgTE6RX) or [Slack channel](https://entgo.io/docs/slack/).",
      "source_content_hash": "d0537932cd96ebc172f07d40432ff073381adb709b3fdc6d263a79438858fef3",
      "node_type": "paragraph",
      "translatable": true,
      "translations": {
        "zh-CN": "如有疑问或需要入门帮助？欢迎加入我们的[Discord服务器](https://discord.gg/qZmPgTE6RX)或[Slack频道](https://entgo.io/docs/slack/)。"
      }
    },
    {
      "segment_id": "3fa1c1e2",
      "source_content": ":::note[For more Ent news and updates:]\n\n- Subscribe to our [Newsletter](https://entgo.substack.com/)\n- Follow us on [Twitter](https://twitter.com/entgo_io)\n- Join us on #ent on the [Gophers Slack](https://entgo.io/docs/slack)\n- Join us on the [Ent Discord Server](https://discord.gg/qZmPgTE6RX)\n\n:::",
      "source_content_hash": "d4f11098ea703d24e53854ec8e2219390959641026efa07de5a588379be52b78",
      "node_type": "containerDirective",
      "translatable": true,
      "translations": {
        "zh-CN": ":::note[获取更多Ent资讯：]\n\n- 订阅[新闻通讯](https://entgo.substack.com/)\n- 关注[Twitter](https://twitter.com/entgo_io)\n- 加入[Gophers Slack](https://entgo.io/docs/slack)的#ent频道\n- 加入[Ent Discord服务器](https://discord.gg/qZmPgTE6RX)\n\n:::"
      }
    }
  ],
  "target_i18n_subpath": "docusaurus-plugin-content-blog/2021-08-05-announcing-upsert-api.md",
  "last_updated_timestamp": "2025-06-05T15:16:18.675650+00:00",
  "schema_version": "1.0",
  "translated_versions": {
    "zh-CN": "8deddfc21a14d13ad6079f68d9dd5cdd6150873b88f1211dbaad8c56edf850cc"
  }
}