---
title: Using Functional Indexes in Ent Schema
id: functional-indexes
slug: functional-indexes
---

import InstallationInstructions from '../components/_installation_instructions.mdx';

函数索引是一种基于表达式值而非列值构建的索引类型。这类索引对于索引未存储在表中的函数或表达式结果非常有用。目前[MySQL、MariaDB](https://atlasgo.io/guides/mysql/functional-indexes)、[PostgreSQL](https://atlasgo.io/guides/postgres/functional-indexes)和[SQLite](https://atlasgo.io/guides/sqlite/functional-indexes)均支持该特性。

本指南将介绍如何通过函数索引扩展Ent schema，并配置schema migration以使用Atlas将函数索引与Ent schema作为单一迁移单元进行管理。

:::info[[Atlas Pro功能](https://atlasgo.io/features#pro-plan)]
本指南使用的[复合Schema](https://atlasgo.io/atlas-schema/projects#data-source-composite_schema)支持为Pro版专属功能。使用前请执行：
```
atlas login
```
:::

## 安装Atlas

<InstallationInstructions />

## 登录Atlas

```shell
$ atlas login a8m
//highlight-next-line-info
You are now connected to "a8m" on Atlas Cloud.
```

## 复合Schema

`ent/schema`包主要用于定义Ent类型（对象）、字段、边及其逻辑。由于Ent仅支持在字段、边（外键）及其组合上定义索引，函数索引在Ent schema中没有直接对应的表示形式。

为了将PostgreSQL schema迁移中的函数索引扩展到Ent类型（表），我们需要配置Atlas从[复合Schema](https://atlasgo.io/atlas-schema/projects#data-source-composite_schema)数据源读取schema状态。请按以下步骤为项目进行配置：

1\. 首先定义一个包含单一类型（表）的基础schema：`User`（表`users`）：

```go title="ent/schema/user.go"
// User holds the schema definition for the User entity.
type User struct {
	ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.String("name").
			Comment("A unique index is defined on lower(name) in schema.sql"),
	}
}
```

2\. 接下来在`schema.sql`文件中为`name`字段定义函数索引：

```sql title="schema.sql" {2}
-- Create a functional (unique) index on the lowercased name column.
CREATE UNIQUE INDEX unique_name ON "users" ((lower("name")));
```

3\. 创建基础的`atlas.hcl`配置文件，通过`composite_schema`同时包含`schema.sql`中定义的函数索引和您的Ent schema：

```hcl title="atlas.hcl"
data "composite_schema" "app" {
  # Load the ent schema first with all tables.
  schema "public" {
    url = "ent://ent/schema"
  }
  # Then, load the functional indexes.
  schema "public" {
    url = "file://schema.sql"
  }
}

env "local" {
  src = data.composite_schema.app.url
  dev = "docker://postgres/15/dev?search_path=public"
}
```

## 使用指南

配置复合schema后，我们可以通过`atlas schema inspect`命令获取其表示形式，为其生成schema迁移文件，应用到数据库等。以下是Atlas的入门命令：

#### 检查Schema

`atlas schema inspect`命令通常用于检查数据库，但我们也可以用它来检查`composite_schema`并打印其SQL表示形式：

```shell
atlas schema inspect \
  --env local \
  --url env://src \
  --format '{{ sql . }}'
```

执行上述命令后将输出如下SQL。

```sql
-- Create "users" table
CREATE TABLE "users" ("id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY, "name" character varying NOT NULL, PRIMARY KEY ("id"));
-- Create index "unique_name" to table: "users"
CREATE UNIQUE INDEX "unique_name" ON "users" ((lower((name)::text)));
```

注意，我们的函数索引定义在`users`表的`name`字段上。

#### 生成Schema迁移文件

执行以下命令为schema生成迁移文件：

```shell
atlas migrate diff \
  --env local
```

注意新生成的迁移文件包含以下内容：

```sql title="migrations/20240712090543.sql"
-- Create "users" table
CREATE TABLE "users" ("id" bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY, "name" character varying NOT NULL, PRIMARY KEY ("id"));
-- Create index "unique_name" to table: "users"
CREATE UNIQUE INDEX "unique_name" ON "users" ((lower((name)::text)));
```

#### 应用迁移

要将生成的迁移应用到数据库，请运行以下命令：

```
atlas migrate apply \
  --env local \
  --url "postgres://postgres:pass@localhost:5432/database?search_path=public&sslmode=disable"
```

:::info[直接向数据库应用模式]

有时需要直接将模式应用到数据库而不生成迁移文件，例如在测试模式变更或启动测试数据库时。此时可使用以下命令直接将模式应用到数据库：

```shell
atlas schema apply \
  --env local \
  --url "postgres://postgres:pass@localhost:5432/database?sslmode=disable"
```

或使用 [Atlas Go SDK](https://github.com/ariga/atlas-go-sdk)：

```go
ac, err := atlasexec.NewClient(".", "atlas")
if err != nil {
	log.Fatalf("初始化客户端失败: %w", err)
}
// 自动用目标模式更新数据库
// 另一种方式是手动使用 'migrate apply' 或 'schema apply'
if _, err := ac.SchemaApply(ctx, &atlasexec.SchemaApplyParams{
	Env: "local",
	URL: "postgres://postgres:pass@localhost:5432/database?sslmode=disable",
	AutoApprove: true,
}); err != nil {
    log.Fatalf("应用模式变更失败: %w", err)
}
```

:::

## 代码示例

完成带有函数索引的Ent模式配置后，预期数据库将强制保证`users`表中`name`字段的唯一性：

```go
// Test that the unique index is enforced.
client.User.Create().SetName("Ariel").SaveX(ctx)
err = client.User.Create().SetName("ariel").Exec(ctx)
require.EqualError(t, err, `ent: constraint failed: pq: duplicate key value violates unique constraint "unique_name"`)

// Type-assert returned error.
var pqerr *pq.Error
require.True(t, errors.As(err, &pqerr))
require.Equal(t, `duplicate key value violates unique constraint "unique_name"`, pqerr.Message)
require.Equal(t, user.Table, pqerr.Table)
require.Equal(t, "unique_name", pqerr.Constraint)
require.Equal(t, pq.ErrorCode("23505"), pqerr.Code, "unique violation")
```

本指南完整代码可在 [GitHub](https://github.com/ent/ent/tree/master/examples/functionalidx) 查看。