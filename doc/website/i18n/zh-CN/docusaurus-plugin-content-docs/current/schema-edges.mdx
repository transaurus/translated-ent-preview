---
id: schema-edges
title: Edges
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## 快速概览

边（Edges）表示实体间的关系（或关联）。例如用户的宠物或群组的成员：

<Tabs>
<TabItem value="graph" label="Graph" default>

![er-group-users](https://entgo.io/images/assets/er_user_pets_groups.png)

</TabItem>
<TabItem value="erd" label="ERD and SQL">

[![erd-group-users](https://entgo.io/images/assets/erd/edges-quick-summary.png)](https://gh.atlasgo.cloud/explore/saved/60129542144)

<div style={{textAlign: 'center'}}>
  <a href={"https://gh.atlasgo.cloud/explore/saved/60129542144"} style={{fontSize: 12}}>ERD was generated by Atlas</a>
</div>

</TabItem>
</Tabs>

上例中展示了通过边声明的两种关系，下面我们进行解析：

1\. `pets` / `owner` 边：表示用户的宠物与宠物的主人：

<Tabs>
<TabItem value="user" label="User" default>

```go title="ent/schema/user.go" {23}
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/schema/edge"
)

// User schema.
type User struct {
	ent.Schema
}

// Fields of the user.
func (User) Fields() []ent.Field {
	return []ent.Field{
		// ...
	}
}

// Edges of the user.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("pets", Pet.Type),
	}
}
```
</TabItem>
<TabItem value="pet" label="Pet">

```go title="ent/schema/pet.go" {23-25}
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/schema/edge"
)

// Pet holds the schema definition for the Pet entity.
type Pet struct {
	ent.Schema
}

// Fields of the Pet.
func (Pet) Fields() []ent.Field {
	return []ent.Field{
		// ...
	}
}

// Edges of the Pet.
func (Pet) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("owner", User.Type).
			Ref("pets").
			Unique(),
	}
}
```
</TabItem>
</Tabs>

可以看出，一个`User`实体可以**拥有多只**宠物，但一个`Pet`实体只能**有一个**主人。  
在关系定义中，`pets`边属于*O2M*（一对多）关系，而`owner`边属于*M2O*（多对一）关系。

`User`模式通过`edge.To`**主导**了`pets/owner`关系，而`Pet`模式仅通过`edge.From`配合`Ref`方法声明了对该关系的反向引用。

`Ref`方法用于说明引用的是`User`模式中的哪个边，因为同一个模式可能存在多个对外引用关系。

可以通过`Unique`方法控制边/关系的基数性，下文将对此进行更详细的说明。

2\. `users` / `groups` 边：表示群组的成员与用户所属群组：

<Tabs>
<TabItem value="group" label="Group" default>

```go title="ent/schema/group.go" {23}
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/schema/edge"
)

// Group schema.
type Group struct {
	ent.Schema
}

// Fields of the group.
func (Group) Fields() []ent.Field {
	return []ent.Field{
		// ...
	}
}

// Edges of the group.
func (Group) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("users", User.Type),
	}
}
```
</TabItem>
<TabItem value="user" label="User">

```go title="ent/schema/user.go" {23-24}
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/schema/edge"
)

// User schema.
type User struct {
	ent.Schema
}

// Fields of the user.
func (User) Fields() []ent.Field {
	return []ent.Field{
		// ...
	}
}

// Edges of the user.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("groups", Group.Type).
			Ref("users"),
		// "pets" declared in the example above.
		edge.To("pets", Pet.Type),
	}
}
```
</TabItem>
</Tabs>

可以看出，一个`Group`实体可以**包含多个**用户，一个`User`实体可以**属于多个**群组。  
在关系定义中，`users`边属于*M2M*（多对多）关系，`groups`边同样属于*M2M*（多对多）关系。

## To与From构建器

`edge.To`和`edge.From`是用于创建边/关系的两种构建器。

使用`edge.To`构建器定义边的模式将主导该关系，而`edge.From`构建器仅用于创建关系的反向引用（可使用不同名称）。

下面通过几个示例演示如何用边定义不同类型的关系。

## 关系类型

- [跨类型O2O](#o2o-two-types)
- [同类型O2O](#o2o-same-type)
- [双向O2O](#o2o-bidirectional)
- [跨类型O2M](#o2m-two-types)
- [同类型O2M](#o2m-same-type)
- [跨类型M2M](#m2m-two-types)
- [同类型M2M](#m2m-same-type)
- [双向M2M](#m2m-bidirectional)

## 跨类型O2O

<Tabs>
<TabItem value="graph" label="Graph" default>

![er-user-card](https://entgo.io/images/assets/er_user_card.png)

</TabItem>
<TabItem value="erd" label="ERD and SQL">

[![edges-o2o-two-types](https://entgo.io/images/assets/erd/edges-o2o-two-types.png)](https://gh.atlasgo.cloud/explore/saved/60129542145)

<div style={{textAlign: 'center'}}>
  <a href={"https://gh.atlasgo.cloud/explore/saved/60129542145"} style={{fontSize: 12}}>ERD was generated by Atlas</a>
</div>

</TabItem>
</Tabs>

本例中，一个用户**只能拥有一张**信用卡，一张卡**只能属于一个**所有者。

`User`模式通过`edge.To`定义了名为`card`的边，`Card`模式则通过`edge.From`定义了名为`owner`的反向引用。

<Tabs>
<TabItem value="user" label="User" default>

```go title="ent/schema/user.go"
// Edges of the user.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("card", Card.Type).
			Unique(),
	}
}
```
</TabItem>
<TabItem value="card" label="Card">

```go title="ent/schema/card.go"
// Edges of the Card.
func (Card) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("owner", User.Type).
			Ref("card").
			Unique().
			// We add the "Required" method to the builder
			// to make this edge required on entity creation.
			// i.e. Card cannot be created without its owner.
			Required(),
	}
}
```
</TabItem>
</Tabs>

操作这些边的API如下：

```go
func Do(ctx context.Context, client *ent.Client) error {
	a8m, err := client.User.
		Create().
		SetAge(30).
		SetName("Mashraki").
		Save(ctx)
	if err != nil {
		return fmt.Errorf("creating user: %w", err)
	}
	log.Println("user:", a8m)
	card1, err := client.Card.
		Create().
		SetOwner(a8m).
		SetNumber("1020").
		SetExpired(time.Now().Add(time.Minute)).
		Save(ctx)
	if err != nil {
    	return fmt.Errorf("creating card: %w", err)
    }
	log.Println("card:", card1)
	// Only returns the card of the user,
	// and expects that there's only one.
	card2, err := a8m.QueryCard().Only(ctx)
	if err != nil {
		return fmt.Errorf("querying card: %w", err)
    }
	log.Println("card:", card2)
	// The Card entity is able to query its owner using
	// its back-reference.
	owner, err := card2.QueryOwner().Only(ctx)
	if err != nil {
		return fmt.Errorf("querying owner: %w", err)
    }
	log.Println("owner:", owner)
	return nil
}
```

完整示例参见[GitHub](https://github.com/ent/ent/tree/master/examples/o2o2types)。

## 同类型O2O

<Tabs>
<TabItem value="graph" label="Graph" default>

![er-linked-list](https://entgo.io/images/assets/er_linked_list.png)

</TabItem>
<TabItem value="erd" label="ERD and SQL">

[![edges-linked-list](https://entgo.io/images/assets/erd/edges-o2o-same-type.png)](https://gh.atlasgo.cloud/explore/saved/60129542146)

<div style={{textAlign: 'center'}}>
  <a href={"https://gh.atlasgo.cloud/explore/saved/60129542146"} style={{fontSize: 12}}>ERD was generated by Atlas</a>
</div>

</TabItem>
</Tabs>

在这个链表示例中，我们有一个名为`next`/`prev`的递归关系。列表中的每个节点只能有一个`next`节点。如果节点A通过`next`指向节点B，B可以通过`prev`（反向引用边）获取其指针。

```go title="ent/schema/node.go"
// Edges of the Node.
func (Node) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("next", Node.Type).
			Unique().
			From("prev").
			Unique(),
	}
}
```

如你所见，在相同类型的关系中，可以在同一个构建器中声明边及其引用。

```diff
func (Node) Edges() []ent.Edge {
	return []ent.Edge{
+		edge.To("next", Node.Type).
+			Unique().
+			From("prev").
+			Unique(),

-		edge.To("next", Node.Type).
-			Unique(),
-		edge.From("prev", Node.Type).
-			Ref("next").
-			Unique(),
	}
}
```

与这些边交互的API如下：

```go
func Do(ctx context.Context, client *ent.Client) error {
	head, err := client.Node.
		Create().
		SetValue(1).
		Save(ctx)
	if err != nil {
		return fmt.Errorf("creating the head: %w", err)
	}
	curr := head
	// Generate the following linked-list: 1<->2<->3<->4<->5.
	for i := 0; i < 4; i++ {
		curr, err = client.Node.
			Create().
			SetValue(curr.Value + 1).
			SetPrev(curr).
			Save(ctx)
		if err != nil {
			return err
		}
	}

	// Loop over the list and print it. `FirstX` panics if an error occur.
	for curr = head; curr != nil; curr = curr.QueryNext().FirstX(ctx) {
		fmt.Printf("%d ", curr.Value)
	}
	// Output: 1 2 3 4 5

	// Make the linked-list circular:
	// The tail of the list, has no "next".
	tail, err := client.Node.
		Query().
		Where(node.Not(node.HasNext())).
		Only(ctx)
	if err != nil {
		return fmt.Errorf("getting the tail of the list: %v", tail)
	}
	tail, err = tail.Update().SetNext(head).Save(ctx)
	if err != nil {
		return err
	}
	// Check that the change actually applied:
	prev, err := head.QueryPrev().Only(ctx)
	if err != nil {
		return fmt.Errorf("getting head's prev: %w", err)
	}
	fmt.Printf("\n%v", prev.Value == tail.Value)
	// Output: true
	return nil
}
```

完整示例可在[GitHub](https://github.com/ent/ent/tree/master/examples/o2orecur)找到。

## O2O 双向关系

<Tabs>
<TabItem value="graph" label="Graph" default>

![er-user-spouse](https://entgo.io/images/assets/er_user_spouse.png)

</TabItem>
<TabItem value="erd" label="ERD and SQL">

[![edges-o2o-bidirectional](https://entgo.io/images/assets/erd/edges-o2o-bidirectional.png)](https://gh.atlasgo.cloud/explore/saved/60129542147)

<div style={{textAlign: 'center'}}>
  <a href={"https://gh.atlasgo.cloud/explore/saved/60129542147"} style={{fontSize: 12}}>ERD was generated by Atlas</a>
</div>

</TabItem>
</Tabs>

在这个用户-配偶示例中，我们有一个名为`spouse`的对称O2O关系。每个用户只能有一个配偶。如果用户A将其配偶（通过`spouse`边）设置为B，B可以通过`spouse`边获取其配偶。

注意，在双向边的情况下没有所有者/反向引用的概念。

```go title="ent/schema/user.go"
// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("spouse", User.Type).
			Unique(),
	}
}
```

与该边交互的API如下：

```go
func Do(ctx context.Context, client *ent.Client) error {
	a8m, err := client.User.
		Create().
		SetAge(30).
		SetName("a8m").
		Save(ctx)
	if err != nil {
		return fmt.Errorf("creating user: %w", err)
	}
	nati, err := client.User.
		Create().
		SetAge(28).
		SetName("nati").
		SetSpouse(a8m).
		Save(ctx)
	if err != nil {
		return fmt.Errorf("creating user: %w", err)
	}

	// Query the spouse edge.
	// Unlike `Only`, `OnlyX` panics if an error occurs.
	spouse := nati.QuerySpouse().OnlyX(ctx)
	fmt.Println(spouse.Name)
	// Output: a8m

	spouse = a8m.QuerySpouse().OnlyX(ctx)
	fmt.Println(spouse.Name)
	// Output: nati

	// Query how many users have a spouse.
	// Unlike `Count`, `CountX` panics if an error occurs.
	count := client.User.
		Query().
		Where(user.HasSpouse()).
		CountX(ctx)
	fmt.Println(count)
	// Output: 2

	// Get the user, that has a spouse with name="a8m".
	spouse = client.User.
		Query().
		Where(user.HasSpouseWith(user.Name("a8m"))).
		OnlyX(ctx)
	fmt.Println(spouse.Name)
	// Output: nati
	return nil
}
```

注意，外键列可以通过[边字段](#edge-field)选项进行配置并作为实体字段暴露，如下所示：

```go {4,14}
// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.Int("spouse_id").
			Optional(),
    }
}

// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("spouse", User.Type).
			Unique().
			Field("spouse_id"),
	}
}
```

完整示例可在[GitHub](https://github.com/ent/ent/tree/master/examples/o2obidi)找到。

## O2M 两种类型

<Tabs>
<TabItem value="graph" label="Graph" default>

![er-user-pets](https://entgo.io/images/assets/er_user_pets.png)

</TabItem>
<TabItem value="erd" label="ERD and SQL">

[![edges-o2m-two-types](https://entgo.io/images/assets/erd/edges-o2m-two-types.png)](https://gh.atlasgo.cloud/explore/saved/60129542148)

<div style={{textAlign: 'center'}}>
  <a href={"https://gh.atlasgo.cloud/explore/saved/60129542148"} style={{fontSize: 12}}>ERD was generated by Atlas</a>
</div>

</TabItem>
</Tabs>

在这个用户-宠物示例中，我们有一个用户与其宠物之间的O2M关系。每个用户拥有多个宠物，而一个宠物只有一个所有者。如果用户A通过`pets`边添加宠物B，B可以通过`owner`边（反向引用边）获取其所有者。

注意，从`Pet`模式的角度来看，这种关系也是M2O（多对一）。

<Tabs>
<TabItem value="user" label="User" default>

```go title="ent/schema/user.go" {4}
// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("pets", Pet.Type),
	}
}
```
</TabItem>
<TabItem value="pet" label="Pet">

```go title="ent/schema/pet.go" {4-6}
// Edges of the Pet.
func (Pet) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("owner", User.Type).
			Ref("pets").
			Unique(),
	}
}
```
</TabItem>
</Tabs>

与这些边交互的API如下：

```go
func Do(ctx context.Context, client *ent.Client) error {
	// Create the 2 pets.
	pedro, err := client.Pet.
		Create().
		SetName("pedro").
		Save(ctx)
	if err != nil {
		return fmt.Errorf("creating pet: %w", err)
	}
	lola, err := client.Pet.
		Create().
		SetName("lola").
		Save(ctx)
	if err != nil {
		return fmt.Errorf("creating pet: %w", err)
	}
	// Create the user, and add its pets on the creation.
	a8m, err := client.User.
		Create().
		SetAge(30).
		SetName("a8m").
		AddPets(pedro, lola).
		Save(ctx)
	if err != nil {
		return fmt.Errorf("creating user: %w", err)
	}
	fmt.Println("User created:", a8m)
	// Output: User(id=1, age=30, name=a8m)

	// Query the owner. Unlike `Only`, `OnlyX` panics if an error occurs.
	owner := pedro.QueryOwner().OnlyX(ctx)
	fmt.Println(owner.Name)
	// Output: a8m

	// Traverse the sub-graph. Unlike `Count`, `CountX` panics if an error occurs.
	count := pedro.
		QueryOwner(). // a8m
		QueryPets().  // pedro, lola
		CountX(ctx)   // count
	fmt.Println(count)
	// Output: 2
	return nil
}
```

注意，外键列可以通过[边字段](#edge-field)选项进行配置并作为实体字段暴露，如下所示：

```go title="ent/schema/pet.go" {4,15}
// Fields of the Pet.
func (Pet) Fields() []ent.Field {
	return []ent.Field{
		field.Int("owner_id").
			Optional(),
    }
}

// Edges of the Pet.
func (Pet) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("owner", User.Type).
			Ref("pets").
			Unique().
			Field("owner_id"),
	}
}
```

完整示例可在[GitHub](https://github.com/ent/ent/tree/master/examples/o2m2types)找到。

## O2M 相同类型

<Tabs>
<TabItem value="graph" label="Graph" default>

![er-tree](https://entgo.io/images/assets/er_tree.png)

</TabItem>
<TabItem value="erd" label="ERD and SQL">

[![edges-o2m-same-type](https://entgo.io/images/assets/erd/edges-o2m-same-type.png)](https://gh.atlasgo.cloud/explore/saved/60129542149)

<div style={{textAlign: 'center'}}>
  <a href={"https://gh.atlasgo.cloud/explore/saved/60129542149"} style={{fontSize: 12}}>ERD was generated by Atlas</a>
</div>

</TabItem>
</Tabs>

在这个示例中，我们有一个树节点与其子节点（或其父节点）之间的递归O2M关系。树中的每个节点拥有多个子节点，并且只有一个父节点。如果节点A将B添加到其子节点中，B可以通过`owner`边获取其所有者。

```go title="ent/schema/node.go"
// Edges of the Node.
func (Node) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("children", Node.Type).
			From("parent").
			Unique(),
	}
}
```

如你所见，在相同类型的关系中，可以在同一个构建器中声明边及其引用。

```diff
func (Node) Edges() []ent.Edge {
	return []ent.Edge{
+		edge.To("children", Node.Type).
+			From("parent").
+			Unique(),

-		edge.To("children", Node.Type),
-		edge.From("parent", Node.Type).
-			Ref("children").
-			Unique(),
	}
}
```

与这些边交互的API如下：

```go
func Do(ctx context.Context, client *ent.Client) error {
	root, err := client.Node.
		Create().
		SetValue(2).
		Save(ctx)
	if err != nil {
		return fmt.Errorf("creating the root: %w", err)
	}
	// Add additional nodes to the tree:
	//
	//       2
	//     /   \
	//    1     4
	//        /   \
	//       3     5
	//
	// Unlike `Save`, `SaveX` panics if an error occurs.
	n1 := client.Node.
		Create().
		SetValue(1).
		SetParent(root).
		SaveX(ctx)
	n4 := client.Node.
		Create().
		SetValue(4).
		SetParent(root).
		SaveX(ctx)
	n3 := client.Node.
		Create().
		SetValue(3).
		SetParent(n4).
		SaveX(ctx)
	n5 := client.Node.
		Create().
		SetValue(5).
		SetParent(n4).
		SaveX(ctx)

	fmt.Println("Tree leafs", []int{n1.Value, n3.Value, n5.Value})
	// Output: Tree leafs [1 3 5]

	// Get all leafs (nodes without children).
	// Unlike `Int`, `IntX` panics if an error occurs.
	ints := client.Node.
		Query().                             // All nodes.
		Where(node.Not(node.HasChildren())). // Only leafs.
		Order(ent.Asc(node.FieldValue)).     // Order by their `value` field.
		GroupBy(node.FieldValue).            // Extract only the `value` field.
		IntsX(ctx)
	fmt.Println(ints)
	// Output: [1 3 5]

	// Get orphan nodes (nodes without parent).
	// Unlike `Only`, `OnlyX` panics if an error occurs.
	orphan := client.Node.
		Query().
		Where(node.Not(node.HasParent())).
		OnlyX(ctx)
	fmt.Println(orphan)
	// Output: Node(id=1, value=2)

	return nil
}
```

注意，外键列可以通过[边字段](#edge-field)选项进行配置并作为实体字段暴露，如下所示：

```go {4,15}
// Fields of the Node.
func (Node) Fields() []ent.Field {
	return []ent.Field{
		field.Int("parent_id").
			Optional(),
    }
}

// Edges of the Node.
func (Node) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("children", Node.Type).
			From("parent").
			Unique().
			Field("parent_id"),
	}
}
```

完整示例可在[GitHub](https://github.com/ent/ent/tree/master/examples/o2mrecur)找到。

## M2M 两种类型

<Tabs>
<TabItem value="graph" label="Graph" default>

![er-user-groups](https://entgo.io/images/assets/er_user_groups.png)

</TabItem>
<TabItem value="erd" label="ERD and SQL">

[![edges-m2m-two-types](https://entgo.io/images/assets/erd/edges-m2m-two-types.png)](https://gh.atlasgo.cloud/explore/saved/60129542150)

<div style={{textAlign: 'center'}}>
  <a href={"https://gh.atlasgo.cloud/explore/saved/60129542150"} style={{fontSize: 12}}>ERD was generated by Atlas</a>
</div>

</TabItem>
</Tabs>

在这个群组-用户示例中，我们展示了群组与用户之间的多对多关系（M2M）。
每个群组可以包含多个用户，每个用户也可以加入多个群组。

```go title="ent/schema/group.go"
// Edges of the Group.
func (Group) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("users", User.Type),
	}
}
```

```go title="ent/schema/user.go"
// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("groups", Group.Type).
			Ref("users"),
	}
}
```

操作这些关系的API如下：

```go
func Do(ctx context.Context, client *ent.Client) error {
	// Unlike `Save`, `SaveX` panics if an error occurs.
	hub := client.Group.
		Create().
		SetName("GitHub").
		SaveX(ctx)
	lab := client.Group.
		Create().
		SetName("GitLab").
		SaveX(ctx)
	a8m := client.User.
		Create().
		SetAge(30).
		SetName("a8m").
		AddGroups(hub, lab).
		SaveX(ctx)
	nati := client.User.
		Create().
		SetAge(28).
		SetName("nati").
		AddGroups(hub).
		SaveX(ctx)

	// Query the edges.
	groups, err := a8m.
		QueryGroups().
		All(ctx)
	if err != nil {
		return fmt.Errorf("querying a8m groups: %w", err)
	}
	fmt.Println(groups)
	// Output: [Group(id=1, name=GitHub) Group(id=2, name=GitLab)]

	groups, err = nati.
		QueryGroups().
		All(ctx)
	if err != nil {
		return fmt.Errorf("querying nati groups: %w", err)
	}
	fmt.Println(groups)
	// Output: [Group(id=1, name=GitHub)]

	// Traverse the graph.
	users, err := a8m.
		QueryGroups().                                           // [hub, lab]
		Where(group.Not(group.HasUsersWith(user.Name("nati")))). // [lab]
		QueryUsers().                                            // [a8m]
		QueryGroups().                                           // [hub, lab]
		QueryUsers().                                            // [a8m, nati]
		All(ctx)
	if err != nil {
		return fmt.Errorf("traversing the graph: %w", err)
	}
	fmt.Println(users)
	// Output: [User(id=1, age=30, name=a8m) User(id=2, age=28, name=nati)]
	return nil
}
```

:::note
调用`AddGroups`方法（M2M关系）时，若关系已存在且非[边模式](#edge-schema)，则不会执行任何操作：

```go {6}
a8m := client.User.
	Create().
	SetName("a8m").
	AddGroups(
		hub,
		hub, // 无操作.
	).
	SaveX(ctx)
```
:::

完整示例见[GitHub](https://github.com/ent/ent/tree/master/examples/m2m2types)。

## 同类型多对多关系

<Tabs>
<TabItem value="graph" label="Graph" default>

![er-following-followers](https://entgo.io/images/assets/er_following_followers.png)

</TabItem>
<TabItem value="erd" label="ERD and SQL">

[![edges-m2m-same-type](https://entgo.io/images/assets/erd/edges-m2m-same-type.png)](https://gh.atlasgo.cloud/explore/saved/60129542151)

<div style={{textAlign: 'center'}}>
  <a href={"https://gh.atlasgo.cloud/explore/saved/60129542151"} style={{fontSize: 12}}>ERD was generated by Atlas</a>
</div>

</TabItem>
</Tabs>

在这个关注者示例中，我们展示了用户之间的互相关注关系。每个用户可以关注多个用户，也可以被多个用户关注。

```go title="ent/schema/user.go"
// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("following", User.Type).
			From("followers"),
	}
}
```

如你所见，对于同类型的关系，可以在同一个构建器中声明边及其反向引用。

```diff
func (User) Edges() []ent.Edge {
	return []ent.Edge{
+		edge.To("following", User.Type).
+			From("followers"),

-		edge.To("following", User.Type),
-		edge.From("followers", User.Type).
-			Ref("following"),
	}
}
```

操作这些关系的API如下：

```go
func Do(ctx context.Context, client *ent.Client) error {
	// Unlike `Save`, `SaveX` panics if an error occurs.
	a8m := client.User.
		Create().
		SetAge(30).
		SetName("a8m").
		SaveX(ctx)
	nati := client.User.
		Create().
		SetAge(28).
		SetName("nati").
		AddFollowers(a8m).
		SaveX(ctx)

	// Query following/followers:

	flw := a8m.QueryFollowing().AllX(ctx)
	fmt.Println(flw)
	// Output: [User(id=2, age=28, name=nati)]

	flr := a8m.QueryFollowers().AllX(ctx)
	fmt.Println(flr)
	// Output: []

	flw = nati.QueryFollowing().AllX(ctx)
	fmt.Println(flw)
	// Output: []

	flr = nati.QueryFollowers().AllX(ctx)
	fmt.Println(flr)
	// Output: [User(id=1, age=30, name=a8m)]

	// Traverse the graph:

	ages := nati.
		QueryFollowers().       // [a8m]
		QueryFollowing().       // [nati]
		GroupBy(user.FieldAge). // [28]
		IntsX(ctx)
	fmt.Println(ages)
	// Output: [28]

	names := client.User.
		Query().
		Where(user.Not(user.HasFollowers())).
		GroupBy(user.FieldName).
		StringsX(ctx)
	fmt.Println(names)
	// Output: [a8m]
	return nil
}
```

:::note
调用`AddFollowers`方法（M2M关系）时，若关系已存在且非[边模式](#edge-schema)，则不会执行任何操作：

```go {6}
a8m := client.User.
	Create().
	SetName("a8m").
	AddFollowers(
		nati,
		nati, // 无操作.
	).
	SaveX(ctx)
```
:::

完整示例见[GitHub](https://github.com/ent/ent/tree/master/examples/m2mrecur)。

## 双向多对多关系

<Tabs>
<TabItem value="graph" label="Graph" default>

![er-user-friends](https://entgo.io/images/assets/er_user_friends.png)

</TabItem>
<TabItem value="erd" label="ERD and SQL">

[![edges-m2m-bidirectional](https://entgo.io/images/assets/erd/edges-m2m-bidirectional.png)](https://gh.atlasgo.cloud/explore/saved/60129542152)

<div style={{textAlign: 'center'}}>
  <a href={"https://gh.atlasgo.cloud/explore/saved/60129542152"} style={{fontSize: 12}}>ERD was generated by Atlas</a>
</div>

</TabItem>
</Tabs>

在这个用户好友示例中，我们展示了名为`friends`的对称多对多关系。
每个用户可以拥有多个好友。若用户A与B成为好友，B自动成为A的好友。

注意：双向关系中不存在所有者/反向引用的概念。

```go title="ent/schema/user.go"
// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("friends", User.Type),
	}
}
```

操作这些关系的API如下：

```go
func Do(ctx context.Context, client *ent.Client) error {
	// Unlike `Save`, `SaveX` panics if an error occurs.
	a8m := client.User.
		Create().
		SetAge(30).
		SetName("a8m").
		SaveX(ctx)
	nati := client.User.
		Create().
		SetAge(28).
		SetName("nati").
		AddFriends(a8m).
		SaveX(ctx)

	// Query friends. Unlike `All`, `AllX` panics if an error occurs.
	friends := nati.
		QueryFriends().
		AllX(ctx)
	fmt.Println(friends)
	// Output: [User(id=1, age=30, name=a8m)]

	friends = a8m.
		QueryFriends().
		AllX(ctx)
	fmt.Println(friends)
	// Output: [User(id=2, age=28, name=nati)]

	// Query the graph:
	friends = client.User.
		Query().
		Where(user.HasFriends()).
		AllX(ctx)
	fmt.Println(friends)
	// Output: [User(id=1, age=30, name=a8m) User(id=2, age=28, name=nati)]
	return nil
}
```

:::note
调用`AddFriends`方法（双向M2M关系）时，若关系已存在且非[边模式](#edge-schema)，则不会执行任何操作：

```go {6}
a8m := client.User.
	Create().
	SetName("a8m").
	AddFriends(
		nati,
		nati, // 无操作.
	).
	SaveX(ctx)
```
:::

完整示例见[GitHub](https://github.com/ent/ent/tree/master/examples/m2mbidi)。

## 边字段

边的`Field`选项允许将外键作为常规字段暴露在模式中。
注意：只有持有外键（边ID）的关系才能使用此选项。

```go title="ent/schema/post.go"
// Fields of the Post.
func (Post) Fields() []ent.Field {
	return []ent.Field{
		field.Int("author_id").
			Optional(),
	}
}

// Edges of the Post.
func (Post) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("author", User.Type).
			// Bind the "author_id" field to this edge.
			Field("author_id").
			Unique(),
	}
}
```

操作边字段的API如下：

```go
func Do(ctx context.Context, client *ent.Client) error {
    p, err := c.Post.Query().
    	Where(post.AuthorID(id)).
    	OnlyX(ctx)
    if err != nil {
        log.Fatal(err)	
    }
    fmt.Println(p.AuthorID) // Access the "author" foreign-key.
}
```

更多示例见[GitHub](https://github.com/ent/ent/tree/master/entc/integration/edgefield)。

#### 迁移至边字段

如[StorageKey](#storagekey)部分所述，Ent通过`edge.To`配置边的存储键（如外键）。因此，若需向已存在于数据库列中的边添加字段，需按如下方式使用`StorageKey`选项进行设置：

```diff
// Fields of the Post.
func (Post) Fields() []ent.Field {
	return []ent.Field{
+		field.Int("author_id").
+			Optional(),
	}
}

// Edges of the Post.
func (Post) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("author", User.Type).
+			Field("author_id").
+			StorageKey(edge.Column("post_author")).
			Unique(),
	}
}
```

或者，该选项也可在边字段上配置：

```diff
// Fields of the Post.
func (Post) Fields() []ent.Field {
	return []ent.Field{
+		field.Int("author_id").
+			StorageKey("post_author").
+			Optional(),
	}
}
```

如果不确定在使用边字段选项前外键的命名方式，请查看项目中生成的模式描述文件：`<project>/ent/migrate/schema.go`。

## 边模式

边模式是用于多对多(M2M)关系的中间实体模式。通过`Through`选项，用户可为关系定义边模式。这使得用户能够在其公共API中暴露关系、存储额外字段、对边执行CRUD操作，并设置钩子和隐私策略。

#### 用户好友关系示例

以下示例展示了如何使用边模式建模两个用户之间的好友关系，其中包含关系的两个必填字段（`user_id`和`friend_id`），以及一个在创建时自动设置值的额外字段`created_at`。

<Tabs>
<TabItem value="graph" label="Graph" default>

![er_edgeschema_bidi](https://entgo.io/images/assets/er_edgeschema_bidi.png)

</TabItem>
<TabItem value="erd" label="ERD and SQL">

[![edges-schema](https://entgo.io/images/assets/erd/edges-schema.png)](https://gh.atlasgo.cloud/explore/saved/60129542153)

<div style={{textAlign: 'center'}}>
  <a href={"https://gh.atlasgo.cloud/explore/saved/60129542153"} style={{fontSize: 12}}>ERD was generated by Atlas</a>
</div>

</TabItem>
</Tabs>

<Tabs
defaultValue="user"
values={[
{label: 'User', value: 'user'},
{label: 'Friendship', value: 'friendship'},
]}>
<TabItem value="user">

```go title="ent/schema/user.go" {18}
// User holds the schema definition for the User entity.
type User struct {
	ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.String("name").
			Default("Unknown"),
	}
}

// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("friends", User.Type).
			Through("friendships", Friendship.Type),
	}
}
```

</TabItem>
<TabItem value="friendship">

```go title="ent/schema/friendship.go" {11-12}
// Friendship holds the edge schema definition of the Friendship relationship.
type Friendship struct {
	ent.Schema
}

// Fields of the Friendship.
func (Friendship) Fields() []ent.Field {
	return []ent.Field{
		field.Time("created_at").
			Default(time.Now),
		field.Int("user_id"),
		field.Int("friend_id"),
	}
}

// Edges of the Friendship.
func (Friendship) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("user", User.Type).
			Required().
			Unique().
			Field("user_id"),
		edge.To("friend", User.Type).
			Required().
			Unique().
			Field("friend_id"),
	}
}
```

</TabItem>
</Tabs>

:::info
- 与实体模式类似，若未明确说明，边模式的`ID`字段会自动生成。
- 边模式不能被多个关系共享使用。
- 边模式中的`user_id`和`friend_id`字段作为关系的组成部分是**必填项**。
:::

#### 用户点赞示例

以下示例展示了如何建模用户"点赞"推文的系统，其中点赞时间戳会存储在数据库中。这是在边上存储额外字段的一种方式。

<Tabs
defaultValue="user"
values={[
{label: 'User', value: 'user'},
{label: 'Tweet', value: 'tweet'},
{label: 'Like', value: 'like'},
]}>
<TabItem value="user">

```go title="ent/schema/user.go" {18}
// User holds the schema definition for the User entity.
type User struct {
	ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.String("name").
			Default("Unknown"),
	}
}

// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("liked_tweets", Tweet.Type).
			Through("likes", Like.Type),
	}
}
```

</TabItem>
<TabItem value="tweet">

```go title="ent/schema/tweet.go" {18}
// Tweet holds the schema definition for the Tweet entity.
type Tweet struct {
	ent.Schema
}

// Fields of the Tweet.
func (Tweet) Fields() []ent.Field {
	return []ent.Field{
		field.Text("text"),
	}
}

// Edges of the Tweet.
func (Tweet) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("liked_users", User.Type).
			Ref("liked_tweets").
			Through("likes", Like.Type),
	}
}
```

</TabItem>
<TabItem value="like">

```go title="ent/schema/like.go" {8,17-18}
// Like holds the edge schema definition for the Like edge.
type Like struct {
	ent.Schema
}

func (Like) Annotations() []schema.Annotation {
	return []schema.Annotation{
		field.ID("user_id", "tweet_id"),
	}
}

// Fields of the Like.
func (Like) Fields() []ent.Field {
	return []ent.Field{
		field.Time("liked_at").
			Default(time.Now),
		field.Int("user_id"),
		field.Int("tweet_id"),
	}
}

// Edges of the Like.
func (Like) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("user", User.Type).
			Unique().
			Required().
			Field("user_id"),
		edge.To("tweet", Tweet.Type).
			Unique().
			Required().
			Field("tweet_id"),
	}
}
```

</TabItem>
</Tabs>

:::info
上例中，`field.ID`注解用于告知Ent边模式标识符是由两个边字段`user_id`和`tweet_id`组成的复合主键。因此，`Like`结构体不会生成`ID`字段及其构建方法（如`Get`、`OnlyID`等）。
:::

#### 边模式在其他边类型中的使用

某些情况下，用户希望将O2M/M2O或O2O关系存储在单独的表中（即连接表），以简化未来可能变更边类型的迁移。例如，通过删除唯一约束而非将外键值迁移到新表，将O2M/M2O边改为M2M。

以下示例展示了一个模型，其中用户可以"创作"推文，并约束一条推文只能由一个用户创作。与常规O2M/M2O边不同，通过使用边模式，我们在连接表上通过对`tweet_id`列设置唯一索引来强制执行此约束。未来可删除此约束以允许多个用户参与推文"创作"，从而在不迁移数据到新表的情况下将边类型改为M2M。

<Tabs
defaultValue="user"
values={[
{label: 'User', value: 'user'},
{label: 'Tweet', value: 'tweet'},
{label: 'UserTweet', value: 'usertweet'},
]}>
<TabItem value="user">

```go title="ent/schema/user.go" {18}
// User holds the schema definition for the User entity.
type User struct {
	ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.String("name").
			Default("Unknown"),
	}
}

// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("tweets", Tweet.Type).
			Through("user_tweets", UserTweet.Type),
	}
}
```

</TabItem>
<TabItem value="tweet">

```go title="ent/schema/tweet.go" {18}
// Tweet holds the schema definition for the Tweet entity.
type Tweet struct {
	ent.Schema
}

// Fields of the Tweet.
func (Tweet) Fields() []ent.Field {
	return []ent.Field{
		field.Text("text"),
	}
}

// Edges of the Tweet.
func (Tweet) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("user", User.Type).
			Ref("tweets").
			Through("tweet_user", UserTweet.Type).
			Comment("The uniqueness of the author is enforced on the edge schema"),
	}
}
```

</TabItem>
<TabItem value="usertweet">

```go title="ent/schema/usertweet.go" {33-34}
// UserTweet holds the schema definition for the UserTweet entity.
type UserTweet struct {
	ent.Schema
}

// Fields of the UserTweet.
func (UserTweet) Fields() []ent.Field {
	return []ent.Field{
		field.Time("created_at").
			Default(time.Now),
		field.Int("user_id"),
		field.Int("tweet_id"),
	}
}

// Edges of the UserTweet.
func (UserTweet) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("user", User.Type).
			Unique().
			Required().
			Field("user_id"),
		edge.To("tweet", Tweet.Type).
			Unique().
			Required().
			Field("tweet_id"),
	}
}

// Indexes of the UserTweet.
func (UserTweet) Indexes() []ent.Index {
	return []ent.Index{
		index.Fields("tweet_id").
			Unique(),
	}
}
```

</TabItem>
</Tabs>

## 必填边

通过在构建器上使用`Required`方法，可将边定义为实体创建时的必填项。

```go {7}
// Edges of the Card.
func (Card) Edges() []ent.Edge {
	return []ent.Edge{
		edge.From("owner", User.Type).
			Ref("card").
			Unique().
			Required(),
	}
}
```

在上例中，银行卡实体必须关联所属用户才能被创建。

:::info
请注意，从 [v0.10](https://github.com/ent/ent/releases/tag/v0.10.0) 版本开始，对于非[自引用](#o2m-same-type)的必填边，外键列在数据库中会被创建为 `NOT NULL`。如需迁移现有外键列，请使用 [Atlas 迁移](migrate.md#atlas-integration) 选项。
:::

## 不可变边

不可变边是指只能在实体创建时设置或添加的边，即实体更新构建器不会生成对应的 setter 方法。

```go {8}
// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("tenant", Tenant.Type).
			Field("tenant_id").
			Unique().
			Required().
			Immutable(),
	}
}
```

## 存储键

默认情况下，Ent 通过边所有者（持有 `edge.To` 的 schema）而非反向引用（`edge.From`）来配置边存储键，因为反向引用是可选的且可能被移除。

如需自定义边的存储配置，请按如下方式使用 `StorageKey` 方法：

```go
// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("pets", Pet.Type).
			// Set the column name in the "pets" table for O2M relationship.
			StorageKey(edge.Column("owner_id")),
		edge.To("cars", Car.Type).
			// Set the symbol of the foreign-key constraint for O2M relationship.
			StorageKey(edge.Symbol("cars_owner_id")),
		edge.To("friends", User.Type).
			// Set the join-table, and the column names for a M2M relationship.
			StorageKey(edge.Table("friends"), edge.Columns("user_id", "friend_id")),
		edge.To("groups", Group.Type).
			// Set the join-table, its column names and the symbols
			// of the foreign-key constraints for M2M relationship.
			StorageKey(
				edge.Table("groups"),
				edge.Columns("user_id", "group_id"),
				edge.Symbols("groups_id1", "groups_id2")
			),
	}
}
```

## 结构体标签

可通过 `StructTag` 方法向生成的实体添加自定义结构体标签。注意：若未提供此选项，或提供的标签不包含 `json` 标签，则会自动添加以字段名命名的默认 `json` 标签。

```go
// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("pets", Pet.Type).
			// Override the default json tag "pets" with "owner" for O2M relationship.
			StructTag(`json:"owner"`),
	}
}
```

## 索引

可在多字段和某些边类型上定义索引，但需注意当前这是仅限 SQL 的功能。

详见 [索引](schema-indexes.md) 章节。

## 注释

可通过 `.Comment()` 方法为边添加注释。该注释会出现在生成实体代码中对应边的上方，支持使用 `\n` 转义序列换行。

```go
// Edges of the User.
func (User) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("pets", Pet.Type).
			Comment("Pets that this user is responsible for taking care of.\n" + 
				"May be zero to many, depending on the user.")
	}
}
```

## 注解

`Annotations` 用于在代码生成时为边对象附加任意元数据。模板扩展可以获取这些元数据并在模板中使用。

注意元数据对象必须可序列化为 JSON 原始值（如结构体、map 或切片）。

```go
// Pet schema.
type Pet struct {
	ent.Schema
}

// Edges of the Pet.
func (Pet) Edges() []ent.Edge {
	return []ent.Edge{
		edge.To("owner", User.Type).
			Ref("pets").
			Unique().
			Annotations(entgql.RelayConnection()),
	}
}
```

关于注解及其在模板中的用法，详见 [模板文档](templates.md#annotations)。

## 命名规范

按照惯例，边名称应使用 `snake_case` 格式。Ent 生成的对应结构体字段将遵循 Go 语言的 `PascalCase` 惯例。如需使用 `PascalCase` 格式，可通过 `StorageKey` 或 `StructTag` 方法实现。