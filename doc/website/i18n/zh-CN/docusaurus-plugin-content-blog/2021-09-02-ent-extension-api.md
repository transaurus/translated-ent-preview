---
title: Extending Ent with the Extension API
author: Rotem Tamir
authorURL: "https://github.com/rotemtam"
authorImageURL: "https://s.gravatar.com/avatar/36b3739951a27d2e37251867b7d44b1a?s=80"
authorTwitter: _rtam
---

数月前，[Ariel](https://github.com/a8m) 为 Ent 核心代码提交了一个静默但影响深远的贡献——[扩展 API](https://entgo.io/docs/extensions)。虽然 Ent 长期支持扩展能力（如[代码生成钩子](https://entgo.io/docs/code-gen/#code-generation-hooks)、[外部模板](https://entgo.io/docs/templates/)和[注解](https://entgo.io/docs/templates/#annotations)），但此前缺乏将所有这些组件打包成连贯、自包含模块的便捷方式。本文讨论的[扩展 API](https://entgo.io/docs/extensions)正是为此而生。

许多开源生态的繁荣，恰恰源于它们为开发者提供了扩展小型核心系统的结构化捷径。Node.js 生态虽饱受争议（甚至被[其创始人 Ryan Dahl 批评](https://www.youtube.com/watch?v=M3BM9TB-8yA)），但不可否认 npm 模块极低的发布与使用门槛极大推动了其流行。我在个人博客中分析过[protoc 插件系统](https://rotemtam.com/2021/03/22/creating-a-protoc-plugin-to-gen-go-code/)如何催生 Protobuf 生态繁荣。简言之，唯有模块化设计才能孕育生态。

本文将通过构建示例项目来探索 Ent 的 `Extension` API。

### 快速开始

扩展 API 仅适用于以 [Go 包形式](https://entgo.io/docs/code-gen/#use-entc-as-a-package)使用 Ent 代码生成的项目。初始化项目后，创建 `ent/entc.go` 文件：

```go title=ent/entc.go
//+build ignore

package main

import (
    "log"

    "entgo.io/ent/entc"
    "entgo.io/ent/entc/gen"
    "entgo.io/ent/schema/field"
)

func main() {
    err := entc.Generate("./schema", &gen.Config{})
    if err != nil {
        log.Fatal("running ent codegen:", err)
    }
}
```

接着修改 `ent/generate.go` 来调用我们的 `entc` 文件：

```go title=ent/generate.go
package ent

//go:generate go run entc.go
```

### 创建扩展

所有扩展必须实现 [Extension](https://pkg.go.dev/entgo.io/ent/entc#Extension) 接口：

```go
type Extension interface {
	// Hooks holds an optional list of Hooks to apply
	// on the graph before/after the code-generation.
	Hooks() []gen.Hook
	// Annotations injects global annotations to the gen.Config object that
	// can be accessed globally in all templates. Unlike schema annotations,
	// being serializable to JSON raw value is not mandatory.
	//
	//	{{- with $.Config.Annotations.GQL }}
	//		{{/* Annotation usage goes here. */}}
	//	{{- end }}
	//
	Annotations() []Annotation
	// Templates specifies a list of alternative templates
	// to execute or to override the default.
	Templates() []*gen.Template
	// Options specifies a list of entc.Options to evaluate on
	// the gen.Config before executing the code generation.
	Options() []Option
}
```

为简化扩展开发，开发者可嵌入 [entc.DefaultExtension](https://pkg.go.dev/entgo.io/ent/entc#DefaultExtension) 来避免实现所有方法。在 `entc.go` 中添加：

```go title=ent/entc.go
// ...

// GreetExtension implements entc.Extension.
type GreetExtension {
	entc.DefaultExtension
}
```

当前扩展尚未实现功能。接下来将其接入代码生成配置，在 `entc.go` 的 `entc.Generate` 调用中添加扩展：

```go
err := entc.Generate("./schema", &gen.Config{}, entc.Extensions(&GreetExtension{})
```

### 添加模板

外部模板可打包到扩展中，以增强 Ent 的核心代码生成功能。本示例目标是为每个实体生成名为 `Greet` 的方法，调用时返回包含类型名称的问候语。预期效果如下：

```go
func (u *User) Greet() string {
    return "Greetings, User"
}
```

为此，我们在 `ent/templates/greet.tmpl` 中添加新模板文件：

```gotemplate title="ent/templates/greet.tmpl"
{{ define "greet" }}

    {{/* Add the base header for the generated file */}}
    {{ $pkg := base $.Config.Package }}
    {{ template "header" $ }}

    {{/* Loop over all nodes and add the Greet method */}}
    {{ range $n := $.Nodes }}
        {{ $receiver := $n.Receiver }}
        func ({{ $receiver }} *{{ $n.Name }}) Greet() string {
            return "Greetings, {{ $n.Name }}"
        }
    {{ end }}
{{ end }}
```

接着实现 `Templates` 方法：

```go title="ent/entc.go"
func (*GreetExtension) Templates() []*gen.Template {
	return []*gen.Template{
		gen.MustParse(gen.NewTemplate("greet").ParseFiles("templates/greet.tmpl")),
	}
}
```

现在测试扩展功能。在 `ent/schema/user.go` 中创建 `User` 类型的模式：

```go
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/schema/field"
)

// User holds the schema definition for the User entity.
type User struct {
	ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.String("email_address").
			Unique(),
	}
}
```

运行命令：

```shell
go generate ./...
```

可以看到新生成了 `ent/greet.go` 文件，内容如下：

```go title="ent/greet.go"
// Code generated by ent, DO NOT EDIT.

package ent

func (u *User) Greet() string {
	return "Greetings, User"
}
```

成功！我们的扩展在 Ent 代码生成过程中被调用，并输出了预期的模式代码！

### 添加注解

注解为扩展用户提供了修改代码生成逻辑行为的API接口。要为我们的扩展添加注解功能，需实现`Annotations`方法。假设对于`GreetExtension`，我们希望允许用户配置生成代码中的问候语：

```go
// GreetingWord implements entc.Annotation
type GreetingWord string

func (GreetingWord) Name() string {
	return "GreetingWord"
}
```

首先在`GreetExtension`结构体中添加`word`字段：

```go
type GreetExtension struct {
	entc.DefaultExtension
	Word GreetingWord
}
```

接着实现`Annotations`方法：

```go
func (s *GreetExtension) Annotations() []entc.Annotation {
	return []entc.Annotation{
		s.Word,
	}
}
```

现在模板中即可访问`GreetingWord`注解。修改`ent/templates/greet.tmpl`以使用新注解：

```gotemplate
func ({{ $receiver }} *{{ $n.Name }}) Greet() string {
    return "{{ $.Annotations.GreetingWord }}, {{ $n.Name }}"
}
```

然后修改代码生成配置来设置问候语注解：

```go title="ent/entc.go
err := entc.Generate("./schema",
    &gen.Config{},
    entc.Extensions(&GreetExtension{
        Word: GreetingWord("Shalom"),
    }),
)
```

重新运行以下命令查看注解如何控制生成代码：

```shell
go generate ./...
```

最终可观察到生成的`ent/greet.go`文件已更新：

```go
func (u *User) Greet() string {
	return "Shalom, User"
}
```

太棒了！我们成功通过注解实现了对生成方法中问候词的可配置化！

### 更多可能性

除模板和注解外，Extension API还允许开发者通过捆绑`gen.Hook`和`entc.Option`来进一步控制代码生成行为。本文不展开讨论这些功能，如需了解可查阅[官方文档](https://entgo.io/docs/extensions)。

### 总结

本文通过示例演示了如何使用`Extension` API创建Ent代码生成扩展。正如前文所述，允许扩展核心功能的模块化设计对生态繁荣至关重要。目前Ent社区已涌现多个优秀扩展项目：

* [elk](https://github.com/masseelch/elk) - 从Ent模式生成REST端点的扩展
* [entgql](https://github.com/ent/contrib/tree/master/entgql) - 从Ent模式生成GraphQL服务
* [entviz](https://github.com/hedwigz/entviz) - 从Ent模式生成ER图

你是否也有创建Ent扩展的想法？希望本文能证明借助Extension API实现这一目标并不困难。

若有疑问或需要帮助，欢迎加入我们的[Discord服务器](https://discord.gg/qZmPgTE6RX)或[Slack频道](https://entgo.io/docs/slack/)。

:::note[获取更多Ent资讯：]

- 订阅[新闻简报](https://entgo.substack.com/)
- 关注[Twitter](https://twitter.com/entgo_io)
- 加入[Gophers Slack](https://entgo.io/docs/slack)的#ent频道
- 加入[Ent Discord服务器](https://discord.gg/qZmPgTE6RX)

:::