---
title: Generate a fully-working Go gRPC server in two minutes with Ent
author: Rotem Tamir
authorURL: "https://github.com/rotemtam"
authorImageURL: "https://s.gravatar.com/avatar/36b3739951a27d2e37251867b7d44b1a?s=80"
authorTwitter: _rtam
---

![ent + gRPC](https://entgo.io/images/assets/ent-grpc.jpg)

## 简介

在软件工程组织规模扩大时，以中心化、语言中立的方式定义实体模式具有[诸多优势](https://rotemtam.com/2019/06/28/the-statically-typed-org/)。为此，许多组织采用[Protocol Buffers](https://developers.google.com/protocol-buffers)作为其[接口定义语言](https://en.wikipedia.org/wiki/Interface_description_language)(IDL)。此外，基于Protobuf的RPC框架gRPC（模仿Google内部[Stubby](https://grpc.io/blog/principles/#motivation)设计）因其高效性和代码生成能力正日益流行。

作为IDL，gRPC并未规定数据访问层的具体实现方案，因此实现方式差异较大。Ent作为构建Go应用数据访问层的天然选择，与gRPC技术结合具有巨大潜力。

今天我们发布实验性版本`entproto`——一个为ent用户提供Protobuf和gRPC支持的Go包及命令行工具。通过`entproto`，开发者可在几分钟内搭建功能完整的CRUD gRPC服务端。本文将具体演示实现过程。

## 环境配置

本教程最终版本已发布于[GitHub](https://github.com/rotemtam/ent-grpc-example)，您可通过克隆仓库跟随操作。

首先为项目初始化新的Go模块：

```console
mkdir ent-grpc-example
cd ent-grpc-example
go mod init ent-grpc-example
```

接着使用`go run`调用ent代码生成器初始化模式：

```console
go run -mod=mod entgo.io/ent/cmd/ent new User
```

当前目录结构应如下所示：

```console
.
├── ent
│   ├── generate.go
│   └── schema
│       └── user.go
├── go.mod
└── go.sum
```

接下来添加`entproto`包至项目：

```console
go get -u entgo.io/contrib/entproto
```

现在定义`User`实体模式。编辑`ent/schema/user.go`：

```go
package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/schema"
)

// User holds the schema definition for the User entity.
type User struct {
	ent.Schema
}

// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.String("name").
			Unique(),
		field.String("email_address").
			Unique(),
	}
}
```

本步骤中，我们为`User`实体添加了两个唯一字段：`name`和`email_address`。`ent.Schema`仅是模式定义，需通过Ent代码生成工具生成可用代码。运行：

```console
go generate ./...
```

注意此时已根据模式定义生成大量新文件：

```console
├── ent
│   ├── client.go
│   ├── config.go
// .... many more
│   ├── user
│   ├── user.go
│   ├── user_create.go
│   ├── user_delete.go
│   ├── user_query.go
│   └── user_update.go
├── go.mod
└── go.sum
```

至此，我们可以连接数据库、执行迁移创建`users`表并开始读写数据。这些操作在[设置教程](https://entgo.io/docs/tutorial-setup/)中已有涵盖，下面我们直接进入主题——学习如何从模式生成Protobuf定义和gRPC服务端。

## 使用`entproto`生成Go Protobuf

由于ent模式与Protobuf模式并非完全一致，我们需要在模式上添加注解来指导`entproto`生成准确的Protobuf定义（在protobuf术语中称为"Messages"）。

首先需添加`entproto.Message()`注解。这是我们选择加入Protobuf模式生成的声明——并非所有模式实体都需要生成proto消息或gRPC服务定义，该注解提供了这种控制权。在`ent/schema/user.go`中添加：

```go
func (User) Annotations() []schema.Annotation {
	return []schema.Annotation{
		entproto.Message(),
	}
}
```

接下来，我们需要为每个字段添加注解并分配字段编号。请记住，在[定义protobuf消息类型](https://developers.google.com/protocol-buffers/docs/proto3#simple)时，每个字段都必须分配一个唯一编号。为此，我们在每个字段上添加`entproto.Field`注解。更新`ent/schema/user.go`中的`Fields`部分：

```go
// Fields of the User.
func (User) Fields() []ent.Field {
	return []ent.Field{
		field.String("name").
			Unique().
			Annotations(
				entproto.Field(2),
			),
		field.String("email_address").
			Unique().
			Annotations(
				entproto.Field(3),
			),
	}
}
```

注意我们没有从1开始编号字段，这是因为`ent`会隐式创建实体的`ID`字段，该字段会自动分配编号1。现在我们可以生成protobuf消息类型定义。为此，我们将在`ent/generate.go`中添加一个`go:generate`指令来调用`entproto`命令行工具。该文件现在应如下所示：

```go
package ent

//go:generate go run -mod=mod entgo.io/ent/cmd/ent generate ./schema
//go:generate go run -mod=mod entgo.io/contrib/entproto/cmd/entproto -path ./schema
```

让我们重新生成代码：

```console
go generate ./...
```

观察到一个新目录`ent/proto`被创建，它将包含所有与protobuf相关的生成代码。目前包含：

```console
ent/proto
└── entpb
    ├── entpb.proto
    └── generate.go
```

生成了两个文件。让我们查看它们的内容：

```protobuf
// Code generated by entproto. DO NOT EDIT.
syntax = "proto3";

package entpb;

option go_package = "ent-grpc-example/ent/proto/entpb";

message User {
  int32 id = 1;

  string user_name = 2;

  string email_address = 3;
}
```

很好！创建了一个新的`.proto`文件，其中包含映射到我们`User`模式的消息类型定义！

```go
package entpb
//go:generate protoc -I=.. --go_out=.. --go-grpc_out=.. --go_opt=paths=source_relative --go-grpc_opt=paths=source_relative --entgrpc_out=.. --entgrpc_opt=paths=source_relative,schema_path=../../schema entpb/entpb.proto
```

还创建了一个新的`generate.go`文件，其中包含对protobuf代码生成器`protoc`的调用指令，说明如何从我们的`.proto`文件生成Go代码。要使此命令正常工作，我们必须先安装`protoc`以及三个protobuf插件：`protoc-gen-go`（生成Go Protobuf结构体）、`protoc-gen-go-grpc`（生成Go gRPC服务接口和客户端）和`protoc-gen-entgrpc`（生成服务接口的实现）。如果尚未安装，请按照以下说明操作：

- [protoc安装指南](https://grpc.io/docs/protoc-installation/)
- [protoc-gen-go + protoc-gen-go-grpc安装指南](https://grpc.io/docs/languages/go/quickstart/)
- 运行`go get -u entgo.io/contrib/entproto/cmd/protoc-gen-entgrpc`安装`protoc-gen-entgrpc`

安装这些依赖项后，我们可以重新运行代码生成：

```console
go generate ./...
```

观察到生成了一个名为`ent/proto/entpb/entpb.pb.go`的新文件，其中包含为我们的实体生成的Go结构体。

让我们编写一个测试来验证一切是否正常。创建一个名为`pb_test.go`的新文件并写入：

```go
package main

import (
	"testing"

	"ent-grpc-example/ent/proto/entpb"
)

func TestUserProto(t *testing.T) {
	user := entpb.User{
		Name:     "rotemtam",
		EmailAddress: "rotemtam@example.com",
	}
	if user.GetName() != "rotemtam" {
		t.Fatal("expected user name to be rotemtam")
	}
	if user.GetEmailAddress() != "rotemtam@example.com" {
		t.Fatal("expected email address to be rotemtam@example.com")
	}
}
```

运行测试：

```console
go get -u./... # install deps of the generated package
go test ./...
```

太棒了！测试通过。我们已成功从Ent模式生成了可工作的Go Protobuf结构体。接下来，让我们看看如何从模式自动生成一个可工作的CRUD gRPC*服务器*。

## 从模式生成全功能gRPC服务器

从`ent.Schema`生成Protobuf结构体很有用，但我们真正感兴趣的是获得一个可以从实际数据库创建、读取、更新和删除实体的服务器。为此，我们只需要修改一行代码！当我们用`entproto.Service`注解模式时，我们告诉`entproto`代码生成器我们希望生成一个gRPC服务定义，`protoc-gen-entgrpc`将读取我们的定义并生成服务实现。编辑`ent/schema/user.go`并修改模式的`Annotations`：

```diff
func (User) Annotations() []schema.Annotation {
	return []schema.Annotation{
		entproto.Message(),
+		entproto.Service(), // <-- add this
	}
}
```

现在重新运行代码生成：

```console
go generate ./...
```

观察`ent/proto/entpb`中的一些有趣变化：

```console
ent/proto/entpb
├── entpb.pb.go
├── entpb.proto
├── entpb_grpc.pb.go
├── entpb_user_service.go
└── generate.go
```

首先，`entproto`向`entpb.proto`添加了一个服务定义：

```protobuf
service UserService {
  rpc Create ( CreateUserRequest ) returns ( User );

  rpc Get ( GetUserRequest ) returns ( User );

  rpc Update ( UpdateUserRequest ) returns ( User );

  rpc Delete ( DeleteUserRequest ) returns ( google.protobuf.Empty );
}
```

此外，还生成了两个新文件。第一个文件`ent_grpc.pb.go`包含gRPC客户端存根和接口定义。打开该文件，你会发现其中包含（除其他内容外）：

```go
// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	Create(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error)
	Get(ctx context.Context, in *GetUserRequest, opts ...grpc.CallOption) (*User, error)
	Update(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error)
	Delete(ctx context.Context, in *DeleteUserRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}
```

第二个文件`entpub_user_service.go`包含该接口的生成实现。例如，`Get`方法的实现：

```go
// Get implements UserServiceServer.Get
func (svc *UserService) Get(ctx context.Context, req *GetUserRequest) (*User, error) {
	get, err := svc.client.User.Get(ctx, int(req.GetId()))
	switch {
	case err == nil:
		return toProtoUser(get), nil
	case ent.IsNotFound(err):
		return nil, status.Errorf(codes.NotFound, "not found: %s", err)
	default:
		return nil, status.Errorf(codes.Internal, "internal error: %s", err)
	}
}
```

不错！接下来，让我们创建一个可以处理服务请求的gRPC服务器。

### 创建服务器

创建一个新文件`cmd/server/main.go`并写入：

```go
package main

import (
	"context"
	"log"
	"net"

	_ "github.com/mattn/go-sqlite3"
	"ent-grpc-example/ent"
	"ent-grpc-example/ent/proto/entpb"
	"google.golang.org/grpc"
)

func main() {
	// Initialize an ent client.
	client, err := ent.Open("sqlite3", "file:ent?mode=memory&cache=shared&_fk=1")
	if err != nil {
		log.Fatalf("failed opening connection to sqlite: %v", err)
	}
	defer client.Close()

	// Run the migration tool (creating tables, etc).
	if err := client.Schema.Create(context.Background()); err != nil {
		log.Fatalf("failed creating schema resources: %v", err)
	}

	// Initialize the generated User service.
	svc := entpb.NewUserService(client)

	// Create a new gRPC server (you can wire multiple services to a single server).
	server := grpc.NewServer()

	// Register the User service with the server.
	entpb.RegisterUserServiceServer(server, svc)

	// Open port 5000 for listening to traffic.
	lis, err := net.Listen("tcp", ":5000")
	if err != nil {
		log.Fatalf("failed listening: %s", err)
	}

	// Listen for traffic indefinitely.
	if err := server.Serve(lis); err != nil {
		log.Fatalf("server ended: %s", err)
	}
}
```

注意我们添加了对`github.com/mattn/go-sqlite3`的导入，因此需要将其添加到模块中：

```console
go get -u github.com/mattn/go-sqlite3
```

接下来，让我们运行服务器，同时编写一个与之通信的客户端：

```console
go run -mod=mod ./cmd/server
```

### 创建客户端

让我们创建一个简单的客户端来向服务器发起调用。创建一个新文件`cmd/client/main.go`并写入：

```go
package main

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"time"

	"ent-grpc-example/ent/proto/entpb"
	"google.golang.org/grpc"
	"google.golang.org/grpc/status"
)

func main() {
	rand.Seed(time.Now().UnixNano())

	// Open a connection to the server.
	conn, err := grpc.Dial(":5000", grpc.WithInsecure())
	if err != nil {
		log.Fatalf("failed connecting to server: %s", err)
	}
	defer conn.Close()

	// Create a User service Client on the connection.
	client := entpb.NewUserServiceClient(conn)

	// Ask the server to create a random User.
	ctx := context.Background()
	user := randomUser()
	created, err := client.Create(ctx, &entpb.CreateUserRequest{
		User: user,
	})
	if err != nil {
		se, _ := status.FromError(err)
		log.Fatalf("failed creating user: status=%s message=%s", se.Code(), se.Message())
	}
	log.Printf("user created with id: %d", created.Id)

	// On a separate RPC invocation, retrieve the user we saved previously.
	get, err := client.Get(ctx, &entpb.GetUserRequest{
		Id: created.Id,
	})
	if err != nil {
		se, _ := status.FromError(err)
		log.Fatalf("failed retrieving user: status=%s message=%s", se.Code(), se.Message())
	}
	log.Printf("retrieved user with id=%d: %v", get.Id, get)
}

func randomUser() *entpb.User {
	return &entpb.User{
		Name:         fmt.Sprintf("user_%d", rand.Int()),
		EmailAddress: fmt.Sprintf("user_%d@example.com", rand.Int()),
	}
}
```

我们的客户端创建了一个连接到服务器监听的5000端口的连接，然后发起一个`Create`请求来创建新用户，接着发起第二个`Get`请求从数据库中检索它。让我们运行客户端代码：

```console
go run ./cmd/client
```

观察输出：

```console
2021/03/18 10:42:58 user created with id: 1
2021/03/18 10:42:58 retrieved user with id=1: id:1 name:"user_730811260095307266" email_address:"user_7338662242574055998@example.com"
```

太棒了！通过在模式上添加几个注解，我们利用代码生成的超能力，快速创建了一个可工作的gRPC服务器！

## 注意事项与限制

`entproto`仍处于实验阶段，缺乏一些基本功能。例如，许多应用程序可能希望在服务上有一个`List`或`Find`方法，但这些目前还不支持。此外，我们计划在不久的将来解决的其他问题包括：

- 目前仅支持“唯一”边（O2O、O2M）。
- 生成的“变异”方法（Create/Update）目前会设置所有字段，忽略零值/null值以及字段的可空性。
- 所有字段都从gRPC请求复制到ent客户端，还计划通过添加字段/边注解来支持配置某些字段不可通过服务设置。

## 后续步骤

我们相信`ent` + gRPC可以成为在Go中构建服务器应用程序的绝佳方式。例如，为了对我们的应用程序管理的实体设置细粒度的访问控制，开发者已经可以使用开箱即用的[隐私策略](https://entgo.io/docs/privacy/)与gRPC集成。要在实体的不同生命周期事件上运行任意Go代码，开发者可以利用自定义[钩子](https://entgo.io/docs/hooks/)。

你想用`ent`构建gRPC服务器吗？如果你需要帮助设置或希望集成支持你的用例，请通过我们的[GitHub讨论页面](https://github.com/ent/ent/discussions)、[Gophers Slack](https://app.slack.com/client/T029RQSE6/C01FMSQDT53)上的#ent频道或我们的[Discord服务器](https://discord.gg/qZmPgTE6RX)联系我们。

:::note[获取更多 Ent 资讯与更新：]
- 订阅我们的[新闻通讯](https://entgo.substack.com/)
- 在[Twitter](https://twitter.com/entgo_io)上关注我们
- 加入[Gophers Slack](https://app.slack.com/client/T029RQSE6/C01FMSQDT53)的 #ent 频道
- 加入[Ent Discord 服务器](https://discord.gg/qZmPgTE6RX)