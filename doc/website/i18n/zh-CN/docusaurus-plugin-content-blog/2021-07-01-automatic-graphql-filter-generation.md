---
title: Automatic GraphQL Filter Generation
author: Ariel Mashraki
authorURL: "https://github.com/a8m"
authorImageURL: "https://avatars0.githubusercontent.com/u/7413593"
authorTwitter: arielmashraki
---

#### 内容提要

我们为Ent GraphQL扩展新增了一项集成功能，能够根据`ent/schema`自动生成类型安全的GraphQL过滤器（即`Where`谓词），并支持用户将GraphQL查询无缝映射到Ent查询。

例如，要获取所有状态为`COMPLETED`的待办事项，可执行以下查询：

````graphql
query QueryAllCompletedTodos {
  todos(
    where: {
      status: COMPLETED,
    },
  ) {
    edges {
      node {
        id
      }
    }
  }
}
````

生成的GraphQL过滤器遵循Ent语法规范。这意味着以下查询同样有效：

```graphql
query FilterTodos {
  todos(
    where: {
      or: [
        {
          hasParent: false,
          status: COMPLETED,
        },
        {
          status: IN_PROGRESS,
          hasParentWith: {
            priorityLT: 1,
            statusNEQ: COMPLETED,
          },
        }
      ]
    },
  ) {
    edges {
      node {
        id
      }
    }
  }
}
```

### 背景

许多处理Go数据的库选择使用空接口实例（`interface{}`）并通过运行时反射来映射数据结构。除了反射带来的性能损耗外，这种方式对开发团队最大的负面影响在于类型安全的缺失。

当API具备显式声明、编译时可知（甚至能在编码时感知）的特性时，开发者能即时获得关于大量错误的反馈。许多缺陷得以早期发现，开发过程也会更加高效愉悦。

Ent的设计初衷是为处理大型数据模型的团队提供卓越的开发体验。为此我们早期就确立了一个核心设计原则："通过代码生成实现静态类型化且显式的API"。这意味着开发者定义的每个`ent/schema`实体都会生成显式、类型安全的代码。例如在[Ent代码库的文件系统示例](https://github.com/ent/ent/blob/master/examples/fs/)中，可以看到名为`File`的模式定义：

```go
// File holds the schema definition for the File entity.
type File struct {
	ent.Schema
}
// Fields of the File.
func (File) Fields() []ent.Field {
	return []ent.Field{
		field.String("name"),
		field.Bool("deleted").
			Default(false),
		field.Int("parent_id").
			Optional(),
	}
}
```

Ent代码生成器运行时会产生大量谓词函数。例如以下用于按`name`字段过滤`File`的函数：

```go
package file
// .. truncated ..

// Name applies the EQ predicate on the "name" field.
func Name(v string) predicate.File {
	return predicate.File(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}
```

[GraphQL](https://graphql.org)是Facebook创建的API查询语言。与Ent类似，GraphQL采用图数据模型并支持类型安全查询。约一年前，我们发布了Ent与GraphQL的集成方案。与[gRPC集成](2021-06-28-gprc-ready-for-use.md)类似，该集成旨在帮助开发者轻松创建与Ent对接的API服务，实现对数据库数据的增删改查。

### 自动生成GraphQL过滤器

在最近的社区调研中，Ent+GraphQL集成被列为最受用户欢迎的功能之一。此前该集成仅支持基础数据查询功能。今天我们宣布发布的新特性将开启更多应用场景："GraphQL过滤器自动生成"。

如前所述，Ent代码生成器会为Go代码库维护一套谓词函数，用于显式高效地过滤数据库表数据。但这项能力此前并未（至少未自动化地）提供给Ent+GraphQL集成用户。通过自动生成GraphQL过滤器，开发者只需单行配置变更，即可在GraphQL模式中获得完整的"过滤输入类型"，这些类型可作为谓词用于GraphQL查询。系统还提供运行时代码来解析这些谓词并将其映射为Ent查询。具体示例如下：

### 生成过滤输入类型

要为`ent/schema`中的每个类型生成过滤输入类型（如`TodoWhereInput`），按以下方式编辑`ent/entc.go`配置文件：

```go
// +build ignore

package main

import (
	"log"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/entc"
	"entgo.io/ent/entc/gen"
)

func main() {
	ex, err := entgql.NewExtension(
		entgql.WithWhereFilters(true),
		entgql.WithConfigPath("../gqlgen.yml"),
		entgql.WithSchemaPath("<PATH-TO-GRAPHQL-SCHEMA>"),
	)
	if err != nil {
		log.Fatalf("creating entgql extension: %v", err)
	}
	err = entc.Generate("./schema", &gen.Config{}, entc.Extensions(ex))
	if err != nil {
		log.Fatalf("running ent codegen: %v", err)
	}
}
```

若您初次接触Ent和GraphQL，请参考[入门教程](https://entgo.io/docs/tutorial-todo-gql)。

接着运行 `go generate ./ent/...`。您会注意到Ent已为schema中的每个类型生成了`<T>WhereInput`。Ent会自动更新GraphQL schema，因此您无需手动将它们`autobind`到`gqlgen`。例如：

```go title="ent/where_input.go"
// TodoWhereInput represents a where input for filtering Todo queries.
type TodoWhereInput struct {
	Not *TodoWhereInput   `json:"not,omitempty"`
	Or  []*TodoWhereInput `json:"or,omitempty"`
	And []*TodoWhereInput `json:"and,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "status" field predicates.
	Status      *todo.Status  `json:"status,omitempty"`
	StatusNEQ   *todo.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []todo.Status `json:"statusIn,omitempty"`
	StatusNotIn []todo.Status `json:"statusNotIn,omitempty"`

    // .. truncated ..
}
```

```graphql title="todo.graphql"
"""
TodoWhereInput is used for filtering Todo objects.
Input was generated by ent.
"""
input TodoWhereInput {
  not: TodoWhereInput
  and: [TodoWhereInput!]
  or: [TodoWhereInput!]
  
  """created_at field predicates"""
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  
  """status field predicates"""
  status: Status
  statusNEQ: Status
  statusIn: [Status!]
  statusNotIn: [Status!]
    
  # .. truncated ..
}
```

接下来，要完成集成还需要进行两项更改：

1\. 编辑GraphQL schema以接受新的过滤器类型：

```graphql {8}
type Query {
  todos(
    after: Cursor,
    first: Int,
    before: Cursor,
    last: Int,
    orderBy: TodoOrder,
    where: TodoWhereInput,
  ): TodoConnection!
}
```

2\. 在GraphQL解析器中使用新的过滤器类型：

```go {5}
func (r *queryResolver) Todos(ctx context.Context, after *ent.Cursor, first *int, before *ent.Cursor, last *int, orderBy *ent.TodoOrder, where *ent.TodoWhereInput) (*ent.TodoConnection, error) {
	return r.client.Todo.Query().
		Paginate(ctx, after, first, before, last,
			ent.WithTodoOrder(orderBy),
			ent.WithTodoFilter(where.Filter),
		)
}
```

### 过滤器规范

如上所述，通过新的GraphQL过滤器类型，您可以表达与Go代码中相同的Ent过滤器。

#### 逻辑与、或及非

可通过`not`、`and`和`or`字段添加`Not`、`And`和`Or`运算符。例如：

```graphql
{
  or: [
    {
      status: COMPLETED,
    },
    {
      not: {
        hasParent: true,
        status: IN_PROGRESS,
      }
    }
  ]
}
```

当提供多个过滤字段时，Ent会隐式添加`And`运算符。

```graphql
{
  status: COMPLETED,
  textHasPrefix: "GraphQL",
}
```

上述查询将生成以下Ent查询：

```go
client.Todo.
	Query().
	Where(
		todo.And(
			todo.StatusEQ(todo.StatusCompleted),
			todo.TextHasPrefix("GraphQL"),
		)
	).
	All(ctx)
```

#### 边/关系过滤器

[边(关系)谓词](https://entgo.io/docs/predicates#edge-predicates)可以用相同的Ent语法表达：

```graphql
{
  hasParent: true,
  hasChildrenWith: {
    status: IN_PROGRESS,
  }
}
```

上述查询将生成以下Ent查询：

```go
client.Todo.
	Query().
	Where(
		todo.HasParent(),
		todo.HasChildrenWith(
			todo.StatusEQ(todo.StatusInProgress),
		),
	).
	All(ctx)
```

### 实现示例

完整示例参见[github.com/a8m/ent-graphql-example](https://github.com/a8m/ent-graphql-example)。

### 总结

正如前文所述，Ent将"通过代码生成创建静态类型化且显式的API"作为核心设计原则。通过自动生成GraphQL过滤器，我们进一步强化了这一理念，为开发者在RPC层也提供同样显式、类型安全的开发体验。

有问题？需要入门帮助？欢迎加入我们的[Discord服务器](https://discord.gg/qZmPgTE6RX)或[Slack频道](https://entgo.io/docs/slack)。

:::note[获取更多Ent资讯：]

- 订阅我们的[新闻通讯](https://entgo.substack.com/)
- 关注[Twitter](https://twitter.com/entgo_io)
- 加入[Gophers Slack](https://entgo.io/docs/slack)的#ent频道
- 加入[Ent Discord服务器](https://discord.gg/qZmPgTE6RX)

:::